#ifndef _MSC_VER
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/sysinfo.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <net/if.h>
#include <inttypes.h>
#include <linux/netlink.h>
#include <linux/genetlink.h>
#endif

#include <iostream>
#include <elfio/elfio_dump.hpp>
#include "ksyms.h"
#include "getopt.h"
#include "x64_disasm.h"
#include "arm64_disasm.h"
#include "arm64relocs.h"
#include "ebpf_disasm.h"
#ifndef _MSC_VER
#include "../shared.h"
#include "kmods.h"
#include "lk.h"
#include "minfo.h"
#include "ujit.h"
#endif

int g_opt_v = 0;
int g_opt_h = 0;
int g_dump_bpf_ops = 0;
int g_event_foff = 0;

using namespace ELFIO;

struct x64_thunk
{
  const char *name;
  ud_type reg;
};

void usage(const char *prog)
{
  printf("%s usage: [options] image [symbols]\n", prog);
  printf("Options:\n");
  printf("-B - dump BPF\n");
  printf("-b - check .bss section\n");
  printf("-c - check memory. Achtung - you must first load lkcd driver\n");
  printf("-d - use disasm\n");
  printf("-F - dump super-blocks\n");
  printf("-f - dump ftraces\n");  
  printf("-g - dump cgroups\n");
  printf("-h - hexdump\n");
  printf("-j jit.so\n");
  printf("-H - dump BPF opcodes\n");
  printf("-k - dump kprobes\n");
  printf("-n - dump nets\n");
  printf("-r - check .rodata section\n");
  printf("-S - check security_hooks\n");
  printf("-s - check fs_ops for sysfs files\n");
  printf("-u - dump usb_monitor\n");
  printf("-v - verbose mode\n");
  exit(6);
}

static a64 s_security_hook_heads = 0;

// autogenerated from include/linux/lsm_hook_defs.h
std::vector<lsm_hook> s_hooks = {
 { "binder_set_context_mgr" },
 { "binder_transaction" },
 { "binder_transfer_binder" },
 { "binder_transfer_file" },
 { "ptrace_access_check" },
 { "ptrace_traceme" },
 { "capget" },
 { "capset" },
 { "capable" },
 { "quotactl" },
 { "quota_on" },
 { "syslog" },
 { "settime" },
 { "vm_enough_memory" },
 { "bprm_creds_for_exec" },
 { "bprm_creds_from_file" },
 { "bprm_check_security" },
 { "bprm_committing_creds" },
 { "bprm_committed_creds" },
 { "fs_context_dup" },
 { "fs_context_parse_param" },
 { "sb_alloc_security" },
 { "sb_free_security" },
 { "sb_free_mnt_opts" },
 { "sb_eat_lsm_opts" },
 { "sb_remount" },
 { "sb_kern_mount" },
 { "sb_show_options" },
 { "sb_statfs" },
 { "sb_mount" },
 { "sb_umount" },
 { "sb_pivotroot" },
 { "sb_set_mnt_opts" },
 { "sb_clone_mnt_opts" },
 { "sb_add_mnt_opt" },
 { "move_mount" },
 { "dentry_init_security" },
 { "dentry_create_files_as" },
 { "path_unlink" },
 { "path_mkdir" },
 { "path_rmdir" },
 { "path_mknod" },
 { "path_truncate" },
 { "path_symlink" },
 { "path_link" },
 { "path_rename" },
 { "path_chmod" },
 { "path_chown" },
 { "path_chroot" },
 { "path_notify" },
 { "inode_alloc_security" },
 { "inode_free_security" },
 { "inode_init_security" },
 { "inode_create" },
 { "inode_link" },
 { "inode_unlink" },
 { "inode_symlink" },
 { "inode_mkdir" },
 { "inode_rmdir" },
 { "inode_mknod" },
 { "inode_rename" },
 { "inode_readlink" },
 { "inode_follow_link" },
 { "inode_permission" },
 { "inode_setattr" },
 { "inode_getattr" },
 { "inode_setxattr" },
 { "inode_post_setxattr" },
 { "inode_getxattr" },
 { "inode_listxattr" },
 { "inode_removexattr" },
 { "inode_need_killpriv" },
 { "inode_killpriv" },
 { "inode_getsecurity" },
 { "inode_setsecurity" },
 { "inode_listsecurity" },
 { "inode_getsecid" },
 { "inode_copy_up" },
 { "inode_copy_up_xattr" },
 { "kernfs_init_security" },
 { "file_permission" },
 { "file_alloc_security" },
 { "file_free_security" },
 { "file_ioctl" },
 { "mmap_addr" },
 { "mmap_file" },
 { "file_mprotect" },
 { "file_lock" },
 { "file_fcntl" },
 { "file_set_fowner" },
 { "file_send_sigiotask" },
 { "file_receive" },
 { "file_open" },
 { "task_alloc" },
 { "task_free" },
 { "cred_alloc_blank" },
 { "cred_free" },
 { "cred_prepare" },
 { "cred_transfer" },
 { "cred_getsecid" },
 { "kernel_act_as" },
 { "kernel_create_files_as" },
 { "kernel_module_request" },
 { "kernel_load_data" },
 { "kernel_post_load_data" },
 { "kernel_read_file" },
 { "kernel_post_read_file" },
 { "task_fix_setuid" },
 { "task_fix_setgid" },
 { "task_setpgid" },
 { "task_getpgid" },
 { "task_getsid" },
 { "task_getsecid" },
 { "task_setnice" },
 { "task_setioprio" },
 { "task_getioprio" },
 { "task_prlimit" },
 { "task_setrlimit" },
 { "task_setscheduler" },
 { "task_getscheduler" },
 { "task_movememory" },
 { "task_kill" },
 { "task_prctl" },
 { "task_to_inode" },
 { "ipc_permission" },
 { "ipc_getsecid" },
 { "msg_msg_alloc_security" },
 { "msg_msg_free_security" },
 { "msg_queue_alloc_security" },
 { "msg_queue_free_security" },
 { "msg_queue_associate" },
 { "msg_queue_msgctl" },
 { "msg_queue_msgsnd" },
 { "msg_queue_msgrcv" },
 { "shm_alloc_security" },
 { "shm_free_security" },
 { "shm_associate" },
 { "shm_shmctl" },
 { "shm_shmat" },
 { "sem_alloc_security" },
 { "sem_free_security" },
 { "sem_associate" },
 { "sem_semctl" },
 { "sem_semop" },
 { "netlink_send" },
 { "d_instantiate" },
 { "getprocattr" },
 { "setprocattr" },
 { "ismaclabel" },
 { "secid_to_secctx" },
 { "secctx_to_secid" },
 { "release_secctx" },
 { "inode_invalidate_secctx" },
 { "inode_notifysecctx" },
 { "inode_setsecctx" },
 { "inode_getsecctx" },
 { "post_notification" },
 { "watch_key" },
 { "unix_stream_connect" },
 { "unix_may_send" },
 { "socket_create" },
 { "socket_post_create" },
 { "socket_socketpair" },
 { "socket_bind" },
 { "socket_connect" },
 { "socket_listen" },
 { "socket_accept" },
 { "socket_sendmsg" },
 { "socket_recvmsg" },
 { "socket_getsockname" },
 { "socket_getpeername" },
 { "socket_getsockopt" },
 { "socket_setsockopt" },
 { "socket_shutdown" },
 { "socket_sock_rcv_skb" },
 { "socket_getpeersec_stream" },
 { "socket_getpeersec_dgram" },
 { "sk_alloc_security" },
 { "sk_free_security" },
 { "sk_clone_security" },
 { "sk_getsecid" },
 { "sock_graft" },
 { "inet_conn_request" },
 { "inet_csk_clone" },
 { "inet_conn_established" },
 { "secmark_relabel_packet" },
 { "secmark_refcount_inc" },
 { "secmark_refcount_dec" },
 { "req_classify_flow" },
 { "tun_dev_alloc_security" },
 { "tun_dev_free_security" },
 { "tun_dev_create" },
 { "tun_dev_attach_queue" },
 { "tun_dev_attach" },
 { "tun_dev_open" },
 { "sctp_assoc_request" },
 { "sctp_bind_connect" },
 { "sctp_sk_clone" },
 { "ib_pkey_access" },
 { "ib_endport_manage_subnet" },
 { "ib_alloc_security" },
 { "ib_free_security" },
 { "xfrm_policy_alloc_security" },
 { "xfrm_policy_clone_security" },
 { "xfrm_policy_free_security" },
 { "xfrm_policy_delete_security" },
 { "xfrm_state_alloc" },
 { "xfrm_state_alloc_acquire" },
 { "xfrm_state_free_security" },
 { "xfrm_state_delete_security" },
 { "xfrm_policy_lookup" },
 { "xfrm_state_pol_flow_match" },
 { "xfrm_decode_session" },
 { "key_alloc" },
 { "key_free" },
 { "key_permission" },
 { "key_getsecurity" },
 { "audit_rule_init" },
 { "audit_rule_known" },
 { "audit_rule_match" },
 { "audit_rule_free" },
 { "bpf" },
 { "bpf_map" },
 { "bpf_prog" },
 { "bpf_map_alloc_security" },
 { "bpf_map_free_security" },
 { "bpf_prog_alloc_security" },
 { "bpf_prog_free_security" },
 { "locked_down" },
 { "perf_event_open" },
 { "perf_event_alloc" },
 { "perf_event_free" },
 { "perf_event_read" },
 { "perf_event_write" },
 { "init" },
 { "settime64" },
 { "vm_enough_memory_mm" },
 { "bprm_set_creds" },
 { "bprm_check" },
 { "sb_alloc" },
 { "add_mnt_opt" },
 { "inode_alloc" },
 { "old_inode_init_security" },
 { "file_alloc" },
 { "prepare_creds" },
 { "msg_msg_alloc" },
 { "msg_queue_alloc" },
 { "shm_alloc" },
 { "sem_alloc" },
 { "sock_rcv_skb" },
 { "sk_alloc" },
 { "xfrm_policy_alloc" },
 { "xfrm_policy_clone" },
 { "xfrm_policy_delete" },
 { "xfrm_state_delete" },
 { "bpf_map_alloc" },
 { "bpf_prog_alloc" },
};

static const x64_thunk s_x64_thunks[] = {
  { "__x86_indirect_thunk_rax", UD_R_RAX },
  { "__x86_indirect_thunk_rbx", UD_R_RBX },
  { "__x86_indirect_thunk_rcx", UD_R_RCX },
  { "__x86_indirect_thunk_rdx", UD_R_RDX },
  { "__x86_indirect_thunk_rsi", UD_R_RSI },
  { "__x86_indirect_thunk_rdi", UD_R_RDI },
  { "__x86_indirect_thunk_rbp", UD_R_RBP },
  { "__x86_indirect_thunk_r8",  UD_R_R8 },
  { "__x86_indirect_thunk_r9",  UD_R_R9 },
  { "__x86_indirect_thunk_r10", UD_R_R10 },
  { "__x86_indirect_thunk_r11", UD_R_R11 },
  { "__x86_indirect_thunk_r12", UD_R_R12 },
  { "__x86_indirect_thunk_r13", UD_R_R13 },
  { "__x86_indirect_thunk_r14", UD_R_R14 },
  { "__x86_indirect_thunk_r15", UD_R_R15 },
};

section* find_section(const elfio& reader, a64 addr)
{
  Elf_Half n = reader.sections.size();
  for ( Elf_Half i = 0; i < n; ++i ) 
  {
    section* sec = reader.sections[i];
    auto start = sec->get_address();
    if ( (addr >= start) &&
         addr < (start + sec->get_size())
       )
      return sec;
  }
  return NULL;
}

const char *find_addr(const elfio& reader, a64 addr)
{
  section *s = find_section(reader, addr);
  if ( NULL == s )
    return NULL;
  if ( s->get_type() & SHT_NOBITS )
    return NULL;
  return s->get_data() + (addr - s->get_address());
}

template <typename F>
void dump_arm64_ftraces(const elfio& reader, a64 start, a64 end, F func)
{
  Elf_Half n = reader.sections.size();
  if ( !n )
    return;
  for ( Elf_Half i = 0; i < n; ++i ) 
  {
    section* sec = reader.sections[i];
    if ( sec->get_type() == SHT_RELA )
    {
      const_relocation_section_accessor rsa(reader, sec);
      Elf_Xword relno = rsa.get_entries_num();
      for ( int i = 0; i < relno; i++ )
      {
         Elf64_Addr offset;
         Elf_Word   symbol;
         Elf_Word   type;
         Elf_Sxword addend;
         rsa.get_entry(i, offset, symbol, type, addend);
         if ( offset < start || offset > end )
           continue;
         if ( type != R_AARCH64_RELATIVE )
           continue;
         func(addend);
      }
    }
  }
}

size_t filter_arm64_relocs(const elfio& reader, a64 start, a64 end, a64 fstart, a64 fend, std::map<a64, a64> &filled)
{
  size_t res = 0;
  Elf_Half n = reader.sections.size();
  if ( !n )
    return 0;
  for ( Elf_Half i = 0; i < n; ++i ) 
  {
    section* sec = reader.sections[i];
    if ( sec->get_type() == SHT_RELA )
    {
      const_relocation_section_accessor rsa(reader, sec);
      Elf_Xword relno = rsa.get_entries_num();
      for ( int i = 0; i < relno; i++ )
      {
         Elf64_Addr offset;
         Elf_Word   symbol;
         Elf_Word   type;
         Elf_Sxword addend;
         rsa.get_entry(i, offset, symbol, type, addend);
         if ( offset < start || offset > end )
           continue;
         if ( type != R_AARCH64_RELATIVE )
           continue;
         if ( addend >= fstart && addend < fend )
         {
           filled[offset] = addend;
           res++;
         }
      }
    }
  }
  return res;
}

void dump_patched(a64 curr_addr, char *ptr, char *arg, sa64 delta)
{
   size_t off = 0;
   const char *name = lower_name_by_addr_with_off(curr_addr, &off);
   if ( name != NULL )
   {
     const char *pto = name_by_addr((a64)(arg - delta));
     if ( pto != NULL )
     {
        if ( off )
          printf("mem at %p (%s+%lX) patched to %p (%s)\n", ptr, name, off, arg, pto);
        else
          printf("mem at %p (%s) patched to %p (%s)\n", ptr, name, arg, pto);
      } else {
        if ( off )
          printf("mem at %p (%s+%lX) patched to %p\n", ptr, name, off, arg);
        else
          printf("mem at %p (%s) patched to %p\n", ptr, name, arg);
      }
  } else
     printf("mem at %p patched to %p\n", ptr, arg);
}

void dump_and_check(int fd, int opt_c, sa64 delta, int has_syms, std::map<a64, a64> &filled)
{
  for ( auto &c: filled )
  {
    auto curr_addr = c.first;
    auto addr = c.second;
    if ( g_opt_v )
    {
      size_t off = 0;
      const char *name = lower_name_by_addr_with_off(curr_addr, &off);
      if ( name != NULL )
      {
         const char *pto = name_by_addr(addr);
         if ( pto != NULL )
         {
           if ( off )
             printf("# %s+%lX -> %s\n", name, off, pto);
           else
             printf("# %s -> %s\n", name, pto);
           } else {
             if ( off )
               printf("# %s+%lX\n", name, off);
             else
               printf("# %s\n", name);
           }
         }
         printf("%p\n", (void *)curr_addr);
      }
#ifndef _MSC_VER
      if ( opt_c )
      {
         char *ptr = (char *)curr_addr + delta;
         char *arg = ptr;
         int err = ioctl(fd, IOCTL_READ_PTR, (int *)&arg);
         if ( err )
         {
           printf("read at %p failed, error %d (%s)\n", ptr, errno, strerror(errno));
           continue;
         }
         char *real = (char *)addr + delta;
         if ( real != arg )
         {
           if ( is_inside_kernel((unsigned long)arg) )
           {
              if ( !has_syms )
                printf("mem at %p: %p (must be %p)\n", ptr, arg, real);
              else 
              {
                size_t off = 0;
                const char *name = lower_name_by_addr_with_off(curr_addr, &off);
                if ( name != NULL )
                {
                  const char *pto = name_by_addr((a64)(arg - delta));
                  if ( pto != NULL )
                  {
                     if ( off )
                       printf("mem at %p (%s+%lX) patched to %p (%s)\n", ptr, name, off, arg, pto);
                     else
                       printf("mem at %p (%s) patched to %p (%s)\n", ptr, name, arg, pto);
                   } else {
                     if ( off )
                       printf("mem at %p (%s+%lX) patched to %p\n", ptr, name, off, arg);
                     else
                       printf("mem at %p (%s) patched to %p\n", ptr, name, arg);
                   }
                } else
                   printf("mem at %p: %p (must be %p)\n", ptr, arg, real);
              }
           } else 
           { // address not in kernel
              const char *mname = find_kmod((unsigned long)arg);
              if ( mname )
                printf("mem at %p: %p (must be %p) - patched by %s\n", ptr, arg, real, mname);
              else
                printf("mem at %p: %p (must be %p) - patched by UNKNOWN\n", ptr, arg, real);
            }
         }
      } /* opt_c */
#endif /* !_MSC_VER */
  }
}

#ifndef _MSC_VER
void dump_unnamed_kptr(unsigned long l, sa64 delta)
{
  if ( is_inside_kernel(l) )
  {
    const char *sname = name_by_addr(l - delta);
    if (sname != NULL)
      printf(" %p - kernel!%s\n", (void *)l, sname);
    else
      printf(" %p - kernel\n", (void *)l);
  } else {
    const char *mname = find_kmod(l);
    if ( mname )
      printf(" %p - %s\n", (void *)l, mname);
    else
      printf(" %p UNKNOWN\n", (void *)l);
  }
}

void dump_kptr(unsigned long l, const char *name, sa64 delta)
{
  if (is_inside_kernel(l))
  {
    const char *sname = name_by_addr(l - delta);
    if (sname != NULL)
      printf(" %s: %p - kernel!%s\n", name, (void *)l, sname);
    else
      printf(" %s: %p - kernel\n", name, (void *)l);
  }
  else {
    const char *mname = find_kmod(l);
    if (mname)
      printf(" %s: %p - %s\n", name, (void *)l, mname);
    else
      printf(" %s: %p - UNKNOWN\n", name, (void *)l);
  }
}

void dump_kptr2(unsigned long l, const char *name, sa64 delta)
{
  if (is_inside_kernel(l))
  {
    const char *sname = name_by_addr(l - delta);
    if (sname != NULL)
      printf(" %s: %p - kernel!%s\n", name, (void *)l, sname);
    else
      printf(" %s: %p - kernel\n", name, (void *)l);
  }
  else {
    const char *mname = find_kmod(l);
    if (mname)
      printf(" %s: %p - %s\n", name, (void *)l, mname);
    else
      printf(" %s: %p\n", name, (void *)l);
  }
}

// some template magic
template <typename T>
class dumb_free
{
  public:
   dumb_free()
   {
     m_ptr = NULL;
   }
   dumb_free(T *ptr)
    : m_ptr(ptr)
   { }
   ~dumb_free()
   {
     if ( m_ptr )
       free(m_ptr);
   }
   void operator=(T *arg)
   {
     if ( (m_ptr != NULL) && (m_ptr != arg) )
       free(m_ptr);
     m_ptr = arg;
   }
  protected:
   void *m_ptr;
};

template <typename T>
size_t calc_data_size(size_t n)
{
  return n * sizeof(T) + sizeof(unsigned long);
}

template <typename T, typename F>
void dump_data2arg(int fd, a64 list, a64 lock, sa64 delta, int code, const char *header, const char *ioctl_name, const char *bname, F func)
{
  unsigned long args[3] = { list + delta, lock + delta, 0 };
  int err = ioctl(fd, code, (int *)args);
  if ( err )
  {
    printf("%s count failed, error %d (%s)\n", ioctl_name, errno, strerror(errno));
    return;
  }
  printf("\n%s at %p: %ld\n", header, (void *)(list + delta), args[0]);
  if ( !args[0] )
    return;
  size_t size = calc_data_size<T>(args[0]);
  unsigned long *buf = (unsigned long *)malloc(size);
  if ( !buf )
  {
    printf("cannot alloc buffer for %s, len %lX\n", bname, size);
    return;
  }
  dumb_free<unsigned long> tmp(buf);
  buf[0] = list + delta;
  buf[1] = lock + delta;
  buf[2] = args[0];
  err = ioctl(fd, code, (int *)buf);
  if ( err )
  {
    printf("%s failed, error %d (%s)\n", ioctl_name, errno, strerror(errno));
    return;
  }
  size = buf[0];
  T *curr = (T *)(buf + 1);
  for ( size_t idx = 0; idx < size; idx++, curr++ )
  {
    func(idx, curr);
  }
}

void dump_ftrace_ops(int fd, a64 list, a64 lock, sa64 delta)
{
  if ( !list )
  {
    printf("cannot find ftrace_ops_list\n");
    return;
  }
  if ( !lock )
  {
    printf("cannot find ftrace_lock\n");
    return;
  }
  dump_data2arg<one_ftrace_ops>(fd, list, lock, delta, IOCTL_GET_FTRACE_OPS, "ftrace_ops_list", "IOCTL_GET_FTRACE_OPS", "ftrace_ops",
   [=](size_t idx, const one_ftrace_ops *curr) {
    printf(" [%ld] flags %lX at", idx, curr->flags);
    dump_unnamed_kptr((unsigned long)curr->addr, delta);
    if ( curr->func )
      dump_kptr((unsigned long)curr->func, "  func", delta);
    if ( curr->saved_func )
      dump_kptr((unsigned long)curr->saved_func, "  saved_func", delta);
   }
  );
}

void dump_dynevents_ops(int fd, a64 list, a64 lock, sa64 delta)
{
  if ( !list )
  {
    printf("cannot find dyn_event_ops_list\n");
    return;
  }
  if ( !lock )
  {
    printf("cannot find dyn_event_ops_mutex\n");
    return;
  }
  dump_data2arg<one_dyn_event_op>(fd, list, lock, delta, IOCTL_GET_DYN_EVT_OPS, "dyn_event_ops_list", "IOCTL_GET_DYN_EVT_OPS", "dynevents_ops",
   [=](size_t idx, const one_dyn_event_op *curr) {
    printf(" [%ld] at", idx);
    dump_unnamed_kptr((unsigned long)curr->addr, delta);
    if ( curr->create )
      dump_kptr((unsigned long)curr->create, "  create", delta);
    if ( curr->show )
      dump_kptr((unsigned long)curr->show, "  show", delta);
    if ( curr->is_busy )
      dump_kptr((unsigned long)curr->is_busy, "  is_busy", delta);
    if ( curr->free )
      dump_kptr((unsigned long)curr->free, "  free", delta);
    if ( curr->match )
      dump_kptr((unsigned long)curr->match, "  match", delta);
   }
  );
}

void dump_tracefunc_cmds(int fd, a64 list, a64 lock, sa64 delta)
{
  if ( !list )
  {
    printf("cannot find ftrace_commands\n");
    return;
  }
  if ( !lock )
  {
    printf("cannot find ftrace_cmd_mutex\n");
    return;
  }
  dump_data2arg<one_tracefunc_cmd>(fd, list, lock, delta, IOCTL_GET_FTRACE_CMDS, "ftrace_commands", "IOCTL_GET_FTRACE_CMDS", "ftrace_func_commands", 
   [=](size_t idx, const one_tracefunc_cmd *curr) {
    printf(" [%ld] %s at", idx, curr->name);
    dump_unnamed_kptr((unsigned long)curr->addr, delta);
    if ( curr->func )
      dump_kptr((unsigned long)curr->func, "  func", delta);
   }
  );
}

void dump_trace_exports(int fd, a64 list, a64 lock, sa64 delta)
{
  if ( !list )
  {
    printf("cannot find ftrace_exports_list\n");
    return;
  }
  if ( !lock )
  {
    printf("cannot find ftrace_export_lock\n");
    return;
  }
  dump_data2arg<one_trace_export>(fd, list, lock, delta, IOCTL_GET_TRACE_EXPORTS, "trace_exports", "IOCTL_GET_TRACE_EXPORTS", "trace_exports",
   [=](size_t idx, const one_trace_export *curr) {
    printf(" [%ld] flags %d at", idx, curr->flags);
    dump_unnamed_kptr((unsigned long)curr->addr, delta);
    if ( curr->write )
      dump_kptr((unsigned long)curr->write, "  write", delta);
    }
  );
}

void dump_pmus(int fd, a64 list, a64 lock, sa64 delta)
{
  if ( !list )
  {
    printf("cannot find pmu_idr\n");
    return;
  }
  if ( !lock )
  {
    printf("cannot find pmus_lock\n");
    return;
  }
  dump_data2arg<one_pmu>(fd, list, lock, delta, IOCTL_GET_PMUS, "pmus", "IOCTL_GET_PMUS", "pmus",
   [=](size_t idx, const one_pmu *curr) {
     printf(" [%ld] type %X capabilities %X at ", idx, curr->type, curr->capabilities);
     dump_unnamed_kptr((unsigned long)curr->addr, delta);
     if ( curr->pmu_enable )
       dump_kptr((unsigned long)curr->pmu_enable, "  pmu_enable", delta);
     if ( curr->pmu_disable )
       dump_kptr((unsigned long)curr->pmu_disable, "  pmu_disable", delta);
     if ( curr->event_init )
       dump_kptr((unsigned long)curr->event_init, "  event_init", delta);
     if ( curr->event_mapped )
       dump_kptr((unsigned long)curr->event_mapped, "  event_mapped", delta);
     if ( curr->event_unmapped )
       dump_kptr((unsigned long)curr->event_unmapped, "  event_unmapped", delta);
     if ( curr->add )
       dump_kptr((unsigned long)curr->add, "  add", delta);
     if ( curr->del )
       dump_kptr((unsigned long)curr->del, "  del", delta);
     if ( curr->start )
       dump_kptr((unsigned long)curr->start, "  start", delta);
     if ( curr->stop )
       dump_kptr((unsigned long)curr->stop, "  stop", delta);
     if ( curr->read )
       dump_kptr((unsigned long)curr->read, "  read", delta);
     if ( curr->start_txn )
       dump_kptr((unsigned long)curr->start_txn, "  start_txn", delta);
     if ( curr->commit_txn )
       dump_kptr((unsigned long)curr->commit_txn, "  commit_txn", delta);
     if ( curr->cancel_txn )
       dump_kptr((unsigned long)curr->cancel_txn, "  cancel_txn", delta);
     if ( curr->event_idx )
       dump_kptr((unsigned long)curr->event_idx, "  event_idx", delta);
     if ( curr->sched_task )
       dump_kptr((unsigned long)curr->sched_task, "  sched_task", delta);
     if ( curr->swap_task_ctx )
       dump_kptr((unsigned long)curr->swap_task_ctx, "  swap_task_ctx", delta);
     if ( curr->setup_aux )
       dump_kptr((unsigned long)curr->setup_aux, "  setup_aux", delta);
     if ( curr->free_aux )
       dump_kptr((unsigned long)curr->free_aux, "  free_aux", delta);
     if ( curr->snapshot_aux )
       dump_kptr((unsigned long)curr->snapshot_aux, "  snapshot_aux", delta);
     if ( curr->addr_filters_validate )
       dump_kptr((unsigned long)curr->addr_filters_validate, "  addr_filters_validate", delta);
     if ( curr->addr_filters_sync )
       dump_kptr((unsigned long)curr->addr_filters_sync, "  addr_filters_sync", delta);
     if ( curr->aux_output_match )
       dump_kptr((unsigned long)curr->aux_output_match, "  aux_output_match", delta);
     if ( curr->filter_match )
       dump_kptr((unsigned long)curr->filter_match, "  filter_match", delta);
     if ( curr->check_period )
       dump_kptr((unsigned long)curr->check_period, "  check_period", delta);
   }
  );
}

void dump_event_cmds(int fd, a64 list, a64 lock, sa64 delta)
{
  if ( !list )
  {
    printf("cannot find trigger_commands\n");
    return;
  }
  if ( !lock )
  {
    printf("cannot find trigger_cmd_mutex\n");
    return;
  }
  dump_data2arg<one_event_command>(fd, list, lock, delta, IOCTL_GET_EVENT_CMDS, "trigger_commands", "IOCTL_GET_EVENT_CMDS", "trigger_commands",
   [=](size_t idx, const one_event_command *curr) {
    printf(" [%ld] %s trigger_type %d flags %d at", idx, curr->name, curr->trigger_type, curr->flags);
    dump_unnamed_kptr((unsigned long)curr->addr, delta);
    if ( curr->func )
      dump_kptr((unsigned long)curr->func, "  func", delta);
    if ( curr->reg )
      dump_kptr((unsigned long)curr->reg, "  reg", delta);
    if ( curr->unreg )
      dump_kptr((unsigned long)curr->unreg, "  unreg", delta);
    if ( curr->unreg_all )
      dump_kptr((unsigned long)curr->unreg_all, "  unreg_all", delta);
    if ( curr->set_filter )
      dump_kptr((unsigned long)curr->set_filter, "  set_filter", delta);
    if ( curr->get_trigger_ops )
      dump_kptr((unsigned long)curr->get_trigger_ops, "  get_trigger_ops", delta);
   }
  );
}

// ripped from https://elixir.bootlin.com/linux/v5.11/source/include/uapi/linux/bpf.h#L171
static const char *const bpf_prog_type_names[] = {
 "BPF_PROG_TYPE_UNSPEC",
 "BPF_PROG_TYPE_SOCKET_FILTER",
 "BPF_PROG_TYPE_KPROBE",
 "BPF_PROG_TYPE_SCHED_CLS",
 "BPF_PROG_TYPE_SCHED_ACT",
 "BPF_PROG_TYPE_TRACEPOINT",
 "BPF_PROG_TYPE_XDP",
 "BPF_PROG_TYPE_PERF_EVENT",
 "BPF_PROG_TYPE_CGROUP_SKB",
 "BPF_PROG_TYPE_CGROUP_SOCK",
 "BPF_PROG_TYPE_LWT_IN",
 "BPF_PROG_TYPE_LWT_OUT",
 "BPF_PROG_TYPE_LWT_XMIT",
 "BPF_PROG_TYPE_SOCK_OPS",
 "BPF_PROG_TYPE_SK_SKB",
 "BPF_PROG_TYPE_CGROUP_DEVICE",
 "BPF_PROG_TYPE_SK_MSG",
 "BPF_PROG_TYPE_RAW_TRACEPOINT",
 "BPF_PROG_TYPE_CGROUP_SOCK_ADDR",
 "BPF_PROG_TYPE_LWT_SEG6LOCAL",
 "BPF_PROG_TYPE_LIRC_MODE2",
 "BPF_PROG_TYPE_SK_REUSEPORT",
 "BPF_PROG_TYPE_FLOW_DISSECTOR",
 "BPF_PROG_TYPE_CGROUP_SYSCTL",
 "BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE",
 "BPF_PROG_TYPE_CGROUP_SOCKOPT",
 "BPF_PROG_TYPE_TRACING",
 "BPF_PROG_TYPE_STRUCT_OPS",
 "BPF_PROG_TYPE_EXT",
 "BPF_PROG_TYPE_LSM",
 "BPF_PROG_TYPE_SK_LOOKUP",
};

static const char *get_bpf_prog_type_name(int idx)
{
  if ( idx >= sizeof(bpf_prog_type_names) / sizeof(bpf_prog_type_names[0]) )
    return "";
  return bpf_prog_type_names[idx];
}

// ripped from https://elixir.bootlin.com/linux/v5.18/source/include/uapi/linux/bpf.h#L957
static const char *const bpf_attach_type_names[] = {
 "BPF_CGROUP_INET_INGRESS",
 "BPF_CGROUP_INET_EGRESS",
 "BPF_CGROUP_INET_SOCK_CREATE",
 "BPF_CGROUP_SOCK_OPS",
 "BPF_SK_SKB_STREAM_PARSER",
 "BPF_SK_SKB_STREAM_VERDICT",
 "BPF_CGROUP_DEVICE",
 "BPF_SK_MSG_VERDICT",
 "BPF_CGROUP_INET4_BIND",
 "BPF_CGROUP_INET6_BIND",
 "BPF_CGROUP_INET4_CONNECT",
 "BPF_CGROUP_INET6_CONNECT",
 "BPF_CGROUP_INET4_POST_BIND",
 "BPF_CGROUP_INET6_POST_BIND",
 "BPF_CGROUP_UDP4_SENDMSG",
 "BPF_CGROUP_UDP6_SENDMSG",
 "BPF_LIRC_MODE2",
 "BPF_FLOW_DISSECTOR",
 "BPF_CGROUP_SYSCTL",
 "BPF_CGROUP_UDP4_RECVMSG",
 "BPF_CGROUP_UDP6_RECVMSG",
 "BPF_CGROUP_GETSOCKOPT",
 "BPF_CGROUP_SETSOCKOPT",
 "BPF_TRACE_RAW_TP",
 "BPF_TRACE_FENTRY",
 "BPF_TRACE_FEXIT",
 "BPF_MODIFY_RETURN",
 "BPF_LSM_MAC",
 "BPF_TRACE_ITER",
 "BPF_CGROUP_INET4_GETPEERNAME",
 "BPF_CGROUP_INET6_GETPEERNAME",
 "BPF_CGROUP_INET4_GETSOCKNAME",
 "BPF_CGROUP_INET6_GETSOCKNAME",
 "BPF_XDP_DEVMAP",
 "BPF_CGROUP_INET_SOCK_RELEASE",
 "BPF_XDP_CPUMAP",
 "BPF_SK_LOOKUP",
 "BPF_XDP",
 "BPF_SK_SKB_VERDICT",
 "BPF_SK_REUSEPORT_SELECT",
 "BPF_SK_REUSEPORT_SELECT_OR_MIGRATE",
 "BPF_PERF_EVENT",
 "BPF_TRACE_KPROBE_MULTI",
};

static const char *get_bpf_attach_type_name(int idx)
{
  if ( idx >= sizeof(bpf_attach_type_names) / sizeof(bpf_attach_type_names[0]) )
    return "";
  return bpf_attach_type_names[idx];
}

void show_bpf_progs(size_t bpf_size, const one_bpf_prog *curr, sa64 delta)
{
  for ( size_t j = 0; j < bpf_size; j++, curr++ )
  {
    printf("  [%ld] prog %p id %d type %d len %d jited_len %d aux %p used_maps %d used_btf %d func_cnt %d\n", j, curr->prog, curr->aux_id, curr->prog_type, curr->len, curr->jited_len, 
      curr->aux, curr->used_map_cnt, curr->used_btf_cnt, curr->func_cnt);
    printf("        tag:");
    for ( int i = 0; i < 8; i++ )
      printf(" %2.2X", curr->tag[i]);
    printf("\n");
    if ( curr->bpf_func )
      dump_kptr2((unsigned long)curr->bpf_func, "  bpf_func", delta);
  }
}

void dump_registered_trace_event_calls(int fd, sa64 delta)
{
  unsigned long args[2] = { 0, 0 };
  int err = ioctl(fd, IOCTL_GET_EVT_CALLS, (int *)args);
  if ( err )
  {
    printf("IOCTL_GET_EVT_CALLS count failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  printf("\nregistered trace_event_calls: %ld\n", args[0]);
  if ( !args[0] )
    return;
  size_t size = calc_data_size<one_trace_event_call>(args[0]);
  unsigned long *buf = (unsigned long *)malloc(size);
  if ( !buf )
  {
    printf("cannot alloc buffer for trace_event_calls, len %lX\n", size);
    return;
  }
  dumb_free<unsigned long> tmp(buf);
  buf[0] = 0;
  buf[1] = args[0];
  err = ioctl(fd, IOCTL_GET_EVT_CALLS, (int *)buf);
  if ( err )
  {
    printf("IOCTL_GET_EVT_CALLS failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  size = buf[0];
  one_trace_event_call *curr = (one_trace_event_call *)(buf + 1);
  for ( size_t idx = 0; idx < size; idx++, curr++ )
  {
    if ( curr->bpf_prog )
    {
      if ( curr->perf_cnt )
        printf(" [%ld] flags %X filter %p perf_cnt %ld bpf_cnt %d at", idx, curr->flags, curr->filter, curr->perf_cnt, curr->bpf_cnt);
      else
        printf(" [%ld] flags %X filter %p bpf_cnt %d at", idx, curr->flags, curr->filter, curr->bpf_cnt);
    } else {
      if ( curr->perf_cnt )
        printf(" [%ld] flags %X filter %p perf_cnt %ld at", idx, curr->flags, curr->filter, curr->perf_cnt);
      else
        printf(" [%ld] flags %X filter %p at", idx, curr->flags, curr->filter);
    }
    dump_unnamed_kptr((unsigned long)curr->addr, delta);
    if ( curr->evt_class )
      dump_kptr((unsigned long)curr->evt_class, "  evt_class", delta);
    if ( curr->tp && (curr->flags & 0x10) )
      dump_kptr((unsigned long)curr->tp, "  tp", delta);
    if ( curr->perf_perm )
      dump_kptr((unsigned long)curr->perf_perm, "  perf_perm", delta);
    if ( !curr->bpf_cnt )
      continue;
    size_t bpf_size = calc_data_size<one_bpf_prog>(curr->bpf_cnt);
    unsigned long *bpf_buf = (unsigned long *)malloc(bpf_size);
    if ( !bpf_buf )
      continue;
    dumb_free<unsigned long> tmp2(bpf_buf);
    bpf_buf[0] = (unsigned long)curr->addr;
    bpf_buf[1] = curr->bpf_cnt;
    err = ioctl(fd, IOCTL_GET_EVT_CALLS, (int *)bpf_buf);
    if ( err )
    {
      printf("IOCTL_GET_EVT_CALLS for bpf_progs failed, error %d (%s)\n", errno, strerror(errno));
      continue;
    }
    one_bpf_prog *curr2 = (one_bpf_prog *)(bpf_buf + 1);
    show_bpf_progs(bpf_buf[0], curr2, delta);
  }
}

void dump_bpf_ksyms(int fd, a64 list, a64 lock, sa64 delta)
{
  if ( !list )
  {
    printf("cannot find bpf_kallsyms\n");
    return;
  }
  if ( !lock )
  {
    printf("cannot find bpf_lock\n");
    return;
  }
  dump_data2arg<one_bpf_ksym>(fd, list, lock, delta, IOCTL_GET_BPF_KSYMS, "bpf_kallsyms", "IOCTL_GET_BPF_KSYMS", "bpf_ksyms",
   [](size_t idx, const one_bpf_ksym *curr) {
     printf(" [%ld] ksym %p %p %p %d %s\n", idx, curr->addr, (void *)curr->start, (void *)curr->end, curr->prog ? 1 : 0, curr->name);
   }
  );
}

void dump_bpf_progs(int fd, a64 list, a64 lock, sa64 delta, std::map<void *, std::string> &map_names)
{
  if ( !list )
  {
    printf("cannot find prog_idr\n");
    return;
  }
  if ( !lock )
  {
    printf("cannot find prog_idr_lock\n");
    return;
  }
  dump_data2arg<one_bpf_prog>(fd, list, lock, delta, IOCTL_GET_BPF_PROGS, "prog_idr", "IOCTL_GET_BPF_PROGS", "bpf_progs",
   [=,&map_names](size_t idx, const one_bpf_prog *curr) {
    printf(" [%ld] prog %p id %d len %d jited_len %d aux %p used_maps %d used_btf %d func_cnt %d\n", idx, curr->prog, curr->aux_id, curr->len, curr->jited_len,
      curr->aux, curr->used_map_cnt, curr->used_btf_cnt, curr->func_cnt
    );
    printf("     tag:");
    for ( int i = 0; i < 8; i++ )
      printf(" %2.2X", curr->tag[i]);
    printf("\n");
    printf("  stack_depth: %d\n", curr->stack_depth);
    printf("  num_exentries: %d\n", curr->num_exentries);
    printf("  type: %d %s\n", curr->prog_type, get_bpf_prog_type_name(curr->prog_type));
    printf("  expected_attach_type: %d %s\n", curr->expected_attach_type, get_bpf_attach_type_name(curr->expected_attach_type));
    if ( curr->used_map_cnt )
    {
      // dump body
      const size_t args_len = sizeof(unsigned long) * 4;
      size_t body_len = curr->used_map_cnt * sizeof(void *);
      if ( body_len < args_len )
        body_len = args_len;
      unsigned long *l = (unsigned long *)malloc(body_len);
      if ( !l )
      {
        printf("cannot alloc memory for bpf used maps\n");
        return;
      }
      dumb_free<unsigned long> tmp(l);
      l[0] = list + delta;
      l[1] = lock + delta;
      l[2] = (unsigned long)curr->prog;
      l[3] = body_len;
      int err = ioctl(fd, IOCTL_GET_BPF_USED_MAPS, (int *)l);
      if ( err )
      {
        printf("IOCTL_GET_BPF_USED_MAPS failed, error %d (%s)\n", errno, strerror(errno));
        return;
      }
      // dump used maps
      printf("  used maps:\n");
      for ( int i = 0; i < curr->used_map_cnt; i++ )
      {
        void *map_addr = (void *)l[i];
        auto mi = map_names.find(map_addr);
        if ( mi == map_names.end() )
          printf("   [%d] %p\n", i, map_addr);
        else
          printf("   [%d] %p - %s\n", i, map_addr, mi->second.c_str());
      }      
    }
    if ( curr->bpf_func && curr->jited_len )
    {
      dump_kptr2((unsigned long)curr->bpf_func, "  bpf_func", delta);
      // dump body
      const size_t args_len = sizeof(unsigned long) * 4;
      size_t body_len = curr->jited_len;
      if ( body_len < args_len )
        body_len = args_len;
      unsigned long *l = (unsigned long *)malloc(body_len);
      if ( !l )
      {
        printf("cannot alloc memory for bpf jit code\n");
        return;
      }
      dumb_free<unsigned long> tmp(l);
      l[0] = list + delta;
      l[1] = lock + delta;
      l[2] = (unsigned long)curr->prog;
      l[3] = curr->jited_len;
      int err = ioctl(fd, IOCTL_GET_BPF_PROG_BODY, (int *)l);
      if ( err )
      {
        printf("IOCTL_GET_BPF_PROG_BODY failed, error %d (%s)\n", errno, strerror(errno));
        return;
      }
      if ( g_opt_h )
        HexDump((unsigned char *)l, curr->jited_len);
      x64_jit_disasm dis((a64)curr->bpf_func, (const char *)l, curr->jited_len);
      dis.disasm(delta, map_names);
    }
    if ( curr->len )
    {
      // dump opcodes, each have size 64bit
      const size_t args_len = sizeof(unsigned long) * 4;
      size_t body_len = curr->len * 8;
      if ( body_len < args_len )
        body_len = args_len;
      unsigned long *l = (unsigned long *)malloc(body_len);
      if ( !l )
      {
        printf("cannot alloc memory for bpf body\n");
        return;
      }
      dumb_free<unsigned long> tmp(l);
      l[0] = list + delta;
      l[1] = lock + delta;
      l[2] = (unsigned long)curr->prog;
      l[3] = curr->len * 8;
      int err = ioctl(fd, IOCTL_GET_BPF_OPCODES, (int *)l);
      if ( err )
      {
        printf("IOCTL_GET_BPF_OPCODES failed, error %d (%s)\n", errno, strerror(errno));
        return;
      }
      if ( g_dump_bpf_ops )
        HexDump((unsigned char *)l, curr->len * 8);
      ebpf_disasm((unsigned char *)l, curr->len, stdout);
      put_orig_jit_addr(curr->bpf_func);
      ujit2file(idx, (unsigned char *)l, curr->len, curr->stack_depth);
    }
    printf("\n");
   }
  );
}

// ripped from https://elixir.bootlin.com/linux/v5.18/source/include/uapi/linux/bpf.h#L880
static const char *const bpf_map_type_names[] = {
 "BPF_MAP_TYPE_UNSPEC",
 "BPF_MAP_TYPE_HASH",
 "BPF_MAP_TYPE_ARRAY",
 "BPF_MAP_TYPE_PROG_ARRAY",
 "BPF_MAP_TYPE_PERF_EVENT_ARRAY",
 "BPF_MAP_TYPE_PERCPU_HASH",
 "BPF_MAP_TYPE_PERCPU_ARRAY",
 "BPF_MAP_TYPE_STACK_TRACE",
 "BPF_MAP_TYPE_CGROUP_ARRAY",
 "BPF_MAP_TYPE_LRU_HASH",
 "BPF_MAP_TYPE_LRU_PERCPU_HASH",
 "BPF_MAP_TYPE_LPM_TRIE",
 "BPF_MAP_TYPE_ARRAY_OF_MAPS",
 "BPF_MAP_TYPE_HASH_OF_MAPS",
 "BPF_MAP_TYPE_DEVMAP",
 "BPF_MAP_TYPE_SOCKMAP",
 "BPF_MAP_TYPE_CPUMAP",
 "BPF_MAP_TYPE_XSKMAP",
 "BPF_MAP_TYPE_SOCKHASH",
 "BPF_MAP_TYPE_CGROUP_STORAGE",
 "BPF_MAP_TYPE_REUSEPORT_SOCKARRAY",
 "BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE",
 "BPF_MAP_TYPE_QUEUE",
 "BPF_MAP_TYPE_STACK",
 "BPF_MAP_TYPE_SK_STORAGE",
 "BPF_MAP_TYPE_DEVMAP_HASH",
 "BPF_MAP_TYPE_STRUCT_OPS",
 "BPF_MAP_TYPE_RINGBUF",
 "BPF_MAP_TYPE_INODE_STORAGE",
 "BPF_MAP_TYPE_TASK_STORAGE",
 "BPF_MAP_TYPE_BLOOM_FILTER",
};

static const char *get_bpf_map_type_name(int idx)
{
  if ( idx >= sizeof(bpf_map_type_names) / sizeof(bpf_map_type_names[0]) )
    return "";
  return bpf_map_type_names[idx];
}


// ripped from https://elixir.bootlin.com/linux/v5.18/source/include/uapi/linux/bpf.h#L1006
static const char *const bpf_link_type_names[] = {
 "BPF_LINK_TYPE_UNSPEC",
 "BPF_LINK_TYPE_RAW_TRACEPOINT",
 "BPF_LINK_TYPE_TRACING",
 "BPF_LINK_TYPE_CGROUP",
 "BPF_LINK_TYPE_ITER",
 "BPF_LINK_TYPE_NETNS",
 "BPF_LINK_TYPE_XDP",
 "BPF_LINK_TYPE_PERF_EVENT",
 "BPF_LINK_TYPE_KPROBE_MULTI",
};

static const char *get_bpf_link_type_name(int idx)
{
  if ( idx >= sizeof(bpf_link_type_names) / sizeof(bpf_link_type_names[0]) )
    return "";
  return bpf_link_type_names[idx];
}

void dump_bpf_links(int fd, a64 list, a64 lock, sa64 delta)
{
  if ( !list )
  {
    printf("cannot find link_idr\n");
    return;
  }
  if ( !lock )
  {
    printf("cannot find link_idr_lock\n");
    return;
  }
  dump_data2arg<one_bpf_links>(fd, list, lock, delta, IOCTL_GET_BPF_LINKS, "link_idr", "IOCTL_GET_BPF_LINKS", "bpf_links",
   [=](size_t idx, const one_bpf_links *curr) {
    printf(" [%ld] at %p id %d\n", idx, curr->addr, curr->id);
    printf("  type: %d %s\n", curr->type, get_bpf_link_type_name(curr->type));
    if ( curr->ops )
    {
      dump_kptr((unsigned long)curr->ops, " ops", delta);
      if ( curr->release )
        dump_kptr((unsigned long)curr->release, "  release", delta);
      if ( curr->dealloc )
        dump_kptr((unsigned long)curr->dealloc, "  dealloc", delta);
      if ( curr->detach )
        dump_kptr((unsigned long)curr->detach, "  detach", delta);
      if ( curr->update_prog )
        dump_kptr((unsigned long)curr->update_prog, "  update_prog", delta);
      if ( curr->show_fdinfo )
        dump_kptr((unsigned long)curr->show_fdinfo, "  show_fdinfo", delta);
      if ( curr->fill_link_info )
        dump_kptr((unsigned long)curr->fill_link_info, "  fill_link_info", delta);
    }
    if ( curr->prog.prog )
    {
      printf("  prog %p id %d type %d len %d jited_len %d\n", curr->prog.prog, curr->prog.aux_id, curr->prog.prog_type, curr->prog.len, curr->prog.jited_len);
      if ( curr->prog.bpf_func )
        dump_kptr2((unsigned long)curr->prog.bpf_func, "  bpf_func", delta);     
    }
   }
  );
}

template <typename T>
void dump_jit_option(int fd, a64 addr, sa64 delta, const char *fmt)
{
  char *ptr = (char *)addr + delta;
  char *arg = ptr;
  int err = ioctl(fd, IOCTL_READ_PTR, (int *)&arg);
  if ( err )
  {
     printf("read at %p failed, error %d (%s)\n", ptr, errno, strerror(errno));
     return;
  }
  T val = *(T *)&arg;
  printf(fmt, val);
}

void dump_ftrace_options(int fd, sa64 delta)
{
  auto addr = get_addr("ftrace_enabled");
  if ( addr )
    dump_jit_option<int>(fd, addr, delta, "ftrace_enabled: %d\n");
  addr = get_addr("ftrace_disabled");
  if ( addr )
    dump_jit_option<int>(fd, addr, delta, "ftrace_disabled: %d\n");
  addr = get_addr("last_ftrace_enabled");
  if ( addr )
    dump_jit_option<int>(fd, addr, delta, "last_ftrace_enabled: %d\n");
  addr = get_addr("ftrace_profile_enabled");
  if ( addr )
    dump_jit_option<int>(fd, addr, delta, "ftrace_profile_enabled: %d\n");
  addr = get_addr("ftrace_graph_active");
  if ( addr )
    dump_jit_option<int>(fd, addr, delta, "ftrace_graph_active: %d\n");
}

void dump_jit_options(int fd, sa64 delta)
{
  auto addr = get_addr("bpf_jit_enable");
  if ( addr )
    dump_jit_option<int>(fd, addr, delta, "bpf_jit_enable: %d\n");
  addr = get_addr("bpf_jit_harden");
  if ( addr )
    dump_jit_option<int>(fd, addr, delta, "bpf_jit_harden: %d\n");
  addr = get_addr("bpf_jit_kallsyms");
  if ( addr )
    dump_jit_option<int>(fd, addr, delta, "bpf_jit_kallsyms: %d\n");
  addr = get_addr("bpf_jit_limit");
  if ( addr )
    dump_jit_option<long>(fd, addr, delta, "bpf_jit_limit: %ld\n");
  addr = get_addr("bpf_jit_limit_max");
  if ( addr )
    dump_jit_option<long>(fd, addr, delta, "bpf_jit_limit_max: %ld\n");
}

void dump_bpf_raw_events(int fd, a64 start, a64 end, sa64 delta)
{
  if ( !start )
  {
    printf("cannot find __start__bpf_raw_tp\n");
    return;
  }
  if ( !end )
  {
    printf("cannot find __stop__bpf_raw_tp\n");
    return;
  }
  dump_data2arg<one_bpf_raw_event>(fd, start, end, delta, IOCTL_GET_BPF_RAW_EVENTS, "bpf_raw_tps", "IOCTL_GET_BPF_RAW_EVENTS", "bpf_raw_tps",
   [=](size_t idx, const one_bpf_raw_event *curr) {
     printf(" [%ld] num_args %d ", idx, curr->num_args);
     dump_kptr2((unsigned long)curr->addr, "addr", delta);
     if ( curr->tp )
       dump_kptr((unsigned long)curr->tp, "  tp", delta);
     if ( curr->func )
       dump_kptr((unsigned long)curr->func, "  func", delta);
   }
  );
}

void dump_bpf_maps(int fd, a64 list, a64 lock, sa64 delta, std::map<void *, std::string> &map_names)
{
  if ( !list )
  {
    printf("cannot find map_idr\n");
    return;
  }
  if ( !lock )
  {
    printf("cannot find map_idr_lock\n");
    return;
  }
  dump_data2arg<one_bpf_map>(fd, list, lock, delta, IOCTL_GET_BPF_MAPS, "bpf_maps", "IOCTL_GET_BPF_MAPS", "bpf_maps",
   [=,&map_names](size_t idx, const one_bpf_map *curr) {
      printf(" [%ld] id %d %s at %p\n", idx, curr->id, curr->name, curr->addr);
      if ( curr->ops )
        dump_kptr((unsigned long)curr->ops, "  ops", delta);
      map_names[curr->addr] = curr->name;
      printf("  type: %d %s\n", curr->map_type, get_bpf_map_type_name(curr->map_type));
      printf("  key_size %d value_size %d\n", curr->key_size, curr->value_size);
      if ( curr->btf )
        dump_kptr((unsigned long)curr->btf, "  btf", delta);
   }
  );
}

void dump_bpf_targets(int fd, a64 list, a64 lock, sa64 delta)
{
  if ( !list )
  {
    printf("cannot find targets\n");
    return;
  }
  if ( !lock )
  {
    printf("cannot find targets_mutex\n");
    return;
  }
  dump_data2arg<one_bpf_reg>(fd, list, lock, delta, IOCTL_GET_BPF_REGS, "bpf_iter_reg", "IOCTL_GET_BPF_REGS", "bpf_regs",
   [=](size_t idx, const one_bpf_reg *curr) {
    printf(" [%ld] feature %d at", idx, curr->feature);
    dump_unnamed_kptr((unsigned long)curr->addr, delta);
    if ( curr->attach_target )
      dump_kptr((unsigned long)curr->attach_target, "  attach_target", delta);
    if ( curr->detach_target )
      dump_kptr((unsigned long)curr->detach_target, "  detach_target", delta);
    if ( curr->show_fdinfo )
      dump_kptr((unsigned long)curr->show_fdinfo, "  show_fdinfo", delta);
    if ( curr->fill_link_info )
      dump_kptr((unsigned long)curr->fill_link_info, "  fill_link_info", delta);
    if ( curr->seq_info )
      dump_kptr((unsigned long)curr->seq_info, "  seq_info", delta);
   }
  );
}

void dump_lsm(int fd, sa64 delta)
{
  for ( auto &c: s_hooks )
  {
    if ( !c.list )
      continue;
    unsigned long args[2] = { c.list + delta, 0 };
    if ( !is_inside_kernel(args[0]) )
    {
      printf("%s list has strange address %p\n", c.name.c_str(), (void *)args[0]);
      continue;
    }
#ifdef _DEBUG
    printf("%s at %p\n", c.name.c_str(), (void *)args[0]);
#endif /* _DEBUG */
    int err = ioctl(fd, IOCTL_GET_LSM_HOOKS, (int *)&args);
    if ( err )
    {
      printf("IOCTL_GET_LSM_HOOKS for %s failed, error %d (%s)\n", c.name.c_str(), errno, strerror(errno));
      continue;
    }
    if ( !args[0] )
      continue;
    printf("%s: %ld\n", c.name.c_str(), args[0]);
    size_t size = (1 + args[0]) * sizeof(unsigned long);
    unsigned long *buf = (unsigned long *)malloc(size);
    if ( !buf )
      continue;
    dumb_free<unsigned long> tmp(buf);
    // fill args
    buf[0] = c.list + delta;
    buf[1] = args[0];
    err = err = ioctl(fd, IOCTL_GET_LSM_HOOKS, (int *)buf);
    if ( err )
    {
      printf("IOCTL_GET_LSM_HOOKS for %s failed, error %d (%s)\n", c.name.c_str(), errno, strerror(errno));
      continue;
    }
    size = buf[0];
    for ( auto idx = 0; idx < size; idx++ )
      dump_unnamed_kptr(buf[1 + idx], delta);
  }
}

size_t calc_cgroup_bpf_size(unsigned long n)
{
  const size_t args_size = 6 * sizeof(unsigned long);
  size_t res = sizeof(unsigned long) + n * sizeof(one_bpf_prog);
  return res < args_size ? args_size : res;
}

void dump_cgroup(const one_cgroup *cg, sa64 delta, int fd, unsigned long a1, unsigned long a2, unsigned long root)
{
  printf(" cgroup at %p id %ld serial_nr %ld flags %lX level %d kn %p\n", cg->addr, cg->id, cg->serial_nr, cg->flags, cg->level, cg->kn);
  if ( cg->ss )
    dump_kptr((unsigned long)cg->ss, "ss", delta);
  int i = 0;
  int has_bpf = 0;
  for ( i = 0; i < CG_BPF_MAX; i++ )
  {
    if ( cg->prog_array_cnt[i] )
    {
      has_bpf = 1;
      break;
    }
  }
  if ( !has_bpf )
    return;
  printf(" cgroup BPF:\n");
  for ( i = 0; i < CG_BPF_MAX; i++ )
  {
    if ( !cg->prog_array_cnt[i] )
      continue;
    printf("  %s: %p cnt %ld flags %X\n", get_bpf_attach_type_name(i), cg->prog_array[i], cg->prog_array_cnt[i], cg->bpf_flags[i]);
    size_t size = calc_cgroup_bpf_size(cg->prog_array_cnt[i]);
    unsigned long *buf = (unsigned long *)malloc(size);
    if ( !buf )
      continue;
    dumb_free<unsigned long> tmp(buf);
    // fill args for IOCTL_GET_CGROUP_BPF
    buf[0] = a1;
    buf[1] = a2;
    buf[2] = root;
    buf[3] = (unsigned long)cg->addr;
    buf[4] = i;
    buf[5] = cg->prog_array_cnt[i];
    int err = ioctl(fd, IOCTL_GET_CGROUP_BPF, (int *)buf);
    if ( err )
    {
      printf("IOCTL_GET_CGRP_ROOTS for cgroup %p and index %d failed, error %d (%s)\n", cg->addr, i, errno, strerror(errno));
      continue;
    }
    one_bpf_prog *bpf = (one_bpf_prog *)(buf + 1);
    show_bpf_progs(buf[0], bpf, delta);
  }
}

void dump_groups(int fd, sa64 delta)
{
  unsigned long a1 = get_addr("cgroup_hierarchy_idr");
  if ( !a1 )
  {
    printf("cannot find cgroup_hierarchy_idr\n");
    return;
  }
  unsigned long a2 = get_addr("cgroup_mutex");
  if ( !a2 )
  {
    printf("cannot find cgroup_mutex\n");
    return;
  }
  unsigned long params[3] = { a1 + delta, a2 + delta, 0 };
  int err = ioctl(fd, IOCTL_GET_CGRP_ROOTS, (int *)&params);
  if ( err )
  {
    printf("IOCTL_GET_CGRP_ROOTS count failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  printf("\ncgroup_hierarchy_idr at %p: %ld\n", (void *)(a1 + delta), params[0]);
  if ( !params[0] )
    return;
  size_t size = calc_data_size<one_group_root>(params[0]);
  unsigned long *buf = (unsigned long *)malloc(size);
  if ( !buf )
  {
    printf("cannot alloc buffer for group_roots, len %lX\n", size);
    return;
  }
  dumb_free<unsigned long> tmp(buf);
  buf[0] = a1 + delta;
  buf[1] = a2 + delta;
  buf[2] = params[0];
  err = ioctl(fd, IOCTL_GET_CGRP_ROOTS, (int *)buf);
  if ( err )
  {
    printf("IOCTL_GET_CGRP_ROOTS failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  one_group_root *gr = (one_group_root *)(buf + 1);
  for ( auto cnt = 0; cnt < buf[0]; cnt++, gr++ )
  {
    printf("[%d] %s at %p flags %X hierarchy_id %d nr_cgrps %ld real_cnt %ld\n", cnt, gr->name, gr->addr, gr->flags, gr->hierarchy_id, gr->nr_cgrps, gr->real_cnt);
    dump_cgroup(&gr->grp, delta, fd, a1 + delta, a2 + delta, (unsigned long)gr->addr);
    if ( !gr->real_cnt )
      continue;
    size = calc_data_size<one_cgroup>(gr->real_cnt);
    unsigned long *cbuf = (unsigned long *)malloc(size);
    if ( !cbuf )
      continue;
    dumb_free<unsigned long> ctmp(cbuf);
    // fill params for IOCTL_GET_CGROUPS
    cbuf[0] = a1 + delta;
    cbuf[1] = a2 + delta;
    cbuf[2] = (unsigned long)gr->addr;
    cbuf[3] = gr->real_cnt;
    err = ioctl(fd, IOCTL_GET_CGROUPS, (int *)cbuf);
    if ( err )
    {
      printf("IOCTL_GET_CGROUPS failed, error %d (%s)\n", errno, strerror(errno));
      continue;
    }
    one_cgroup *cg = (one_cgroup *)(cbuf + 1);
    for ( auto cgnt = 0; cgnt < cbuf[0]; cgnt++, cg++ )
    {
      printf(" child %d:\n", cgnt);
      dump_cgroup(cg, delta, fd, a1 + delta, a2 + delta, (unsigned long)gr->addr);
    }
  }
}

void dump_uprobes(int fd, sa64 delta)
{
  unsigned long a1 = get_addr("uprobes_tree");
  if ( !a1 )
  {
    printf("cannot find uprobes_tree\n");
    return;
  }
  unsigned long a2 = get_addr("uprobes_treelock");
  if ( !a2 )
  {
    printf("cannot find uprobes_treelock\n");
    return;
  }
  unsigned long params[2] = { a1 + delta, a2 + delta };
  int err = ioctl(fd, IOCTL_CNT_UPROBES, (int *)&params);
  if ( err )
  {
    printf("IOCTL_CNT_UPROBES count failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  printf("uprobes: %ld\n", params[0]);
  if ( !params[0] )
    return;
  size_t size = calc_data_size<one_uprobe>(params[0]);
  unsigned long *buf = (unsigned long *)malloc(size);
  if ( !buf )
  {
    printf("cannot alloc buffer for uprobes, len %lX\n", size);
    return;
  }
  dumb_free<unsigned long> tmp(buf);
  buf[0] = a1 + delta;
  buf[1] = a2 + delta;
  buf[2] = params[0];
  err = ioctl(fd, IOCTL_UPROBES, (int *)buf);
  if ( err )
  {
    printf("IOCTL_UPROBES failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  one_uprobe *up = (one_uprobe *)(buf + 1);
  for ( auto cnt = 0; cnt < buf[0]; cnt++ )
  {
      printf("[%d] addr %p inode %p ino %ld clnts %ld offset %lX flags %lX %s\n", 
        cnt, up[cnt].addr, up[cnt].inode, up[cnt].i_no, up[cnt].cons_cnt, up[cnt].offset, up[cnt].flags, up[cnt].name);
      if ( !up[cnt].cons_cnt )
        continue;
      size_t client_size = calc_data_size<one_uprobe_consumer>(up[cnt].cons_cnt);
      unsigned long *cbuf = (unsigned long *)malloc(client_size);
      if ( !cbuf )
      {
        printf("cannot alloc buffer for uprobe %p consumers, len %lX\n", up[cnt].addr, client_size);
        continue;
      }
      dumb_free<unsigned long> tmp2(cbuf);
      // form params for IOCTL_CNT_UPROBES
      cbuf[0] = a1 + delta;
      cbuf[1] = a2 + delta;
      cbuf[2] = (unsigned long)up[cnt].addr;
      cbuf[3] = up[cnt].cons_cnt;
      err = ioctl(fd, IOCTL_UPROBES_CONS, (int *)cbuf);
      if ( err )
      {
        printf("IOCTL_UPROBES_CONS for %p failed, error %d (%s)\n", up[cnt].addr, errno, strerror(errno));
        continue;
      }
      // dump consumers
      one_uprobe_consumer *uc = (one_uprobe_consumer *)(cbuf + 1);
      for ( auto cnt2 = 0; cnt2 < cbuf[0]; cnt2++ )
      {
        printf(" consumer[%d] at %p\n", cnt2, uc[cnt2].addr);
        if ( uc[cnt2].handler )
          dump_kptr((unsigned long)uc[cnt2].handler, "  handler", delta);
        if ( uc[cnt2].ret_handler )
          dump_kptr((unsigned long)uc[cnt2].ret_handler, "  ret_handler", delta);
        if ( uc[cnt2].filter )
          dump_kptr((unsigned long)uc[cnt2].filter, "  filter", delta);
      }
  }
}

void dump_protosw(int fd, a64 list, a64 lock, sa64 delta, const char *what)
{
  printf("\n%s at %p:\n", what, (void *)(list + delta));
  for ( int i = 0; i < 11; i++ )
  {
    unsigned long args[4] = { list + delta, lock + delta, (unsigned long)i, 0 };
    int err = ioctl(fd, IOCTL_GET_PROTOSW, (int *)args);
    if ( err )
    {
      printf("IOCTL_GET_PROTOSW count for %d failed, error %d (%s)\n", i, errno, strerror(errno));
      continue;
    }
    if ( !args[0] )
      continue;
    size_t size = calc_data_size<one_protosw>(args[0]);
    unsigned long *buf = (unsigned long *)malloc(size);
    if ( !buf )
      continue;
    dumb_free<unsigned long> tmp(buf);
    buf[0] = list + delta;
    buf[1] = lock + delta;
    buf[2] = i;
    buf[3] = args[0];
    err = ioctl(fd, IOCTL_GET_PROTOSW, (int *)buf);
    if ( err )
    {
      printf("IOCTL_GET_PROTOSW for %d failed, error %d (%s)\n", i, errno, strerror(errno));
      continue;
    }
    size = buf[0];
    printf("[%d]: count %ld\n", i, size);
    struct one_protosw *sb = (struct one_protosw *)(buf + 1);
    for ( size_t idx = 0; idx < size; idx++, sb++ )
    {
      printf(" addr %p type %d protocol %d\n", sb->addr, sb->type, sb->protocol);
      if ( sb->prot )
        dump_kptr((unsigned long)sb->prot, " prot", delta);
      if ( sb->ops )
        dump_kptr((unsigned long)sb->ops, " ops", delta);
    }
  }
}

void dump_rtnl_af_ops(int fd, a64 nca, sa64 delta)
{
  unsigned long args[2] = { nca + delta, 0 };
  int err = ioctl(fd, IOCTL_GET_RTNL_AF_OPS, (int *)args);
  if ( err )
  {
    printf("IOCTL_GET_RTNL_AF_OPS count failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  printf("\nrtnl_af_ops at %p: %ld\n", (void *)(nca + delta), args[0]);
  if ( !args[0] )
    return;
  size_t m = args[0];
  if ( m < 2 )
    m = 2;
  unsigned long *buf = (unsigned long *)malloc(m * sizeof(unsigned long));
  if ( !buf )
    return;
  dumb_free<unsigned long> tmp(buf);
  buf[0] = nca + delta;
  buf[1] = args[0];
  err = ioctl(fd, IOCTL_GET_RTNL_AF_OPS, (int *)buf);
  if ( err )
  {
    printf("IOCTL_GET_RTNL_AF_OPS failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  for ( size_t j = 0; j < buf[0]; j++ )
  {
    dump_unnamed_kptr(buf[1 + j], delta);
  }
}

void dump_link_ops(int fd, a64 nca, sa64 delta)
{
  unsigned long args[2] = { nca + delta, 0 };
  int err = ioctl(fd, IOCTL_GET_LINKS_OPS, (int *)args);
  if ( err )
  {
    printf("IOCTL_GET_LINKS_OPS count failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  printf("\nlink_ops at %p: %ld\n", (void *)(nca + delta), args[0]);
  if ( !args[0] )
    return;
  size_t m = args[0];
  if ( m < 2 )
    m = 2;
  unsigned long *buf = (unsigned long *)malloc(m * sizeof(unsigned long));
  if ( !buf )
    return;
  dumb_free<unsigned long> tmp(buf);
  buf[0] = nca + delta;
  buf[1] = args[0];
  err = ioctl(fd, IOCTL_GET_LINKS_OPS, (int *)buf);
  if ( err )
  {
    printf("IOCTL_GET_LINKS_OPS failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  for ( size_t j = 0; j < buf[0]; j++ )
  {
    dump_unnamed_kptr(buf[1 + j], delta);
  }
}

void dump_ulps(int fd, a64 nca, a64 plock, sa64 delta)
{
  if ( !nca )
  {
    printf("cannot find tcp_ulp_list\n");
    return;
  }
  if ( !plock )
  {
    printf("cannot find tcp_ulp_list_lock\n");
    return;
  }
  dump_data2arg<one_tcp_ulp_ops>(fd, nca, plock, delta, IOCTL_GET_ULP_OPS, "tcp_ulp_list", "IOCTL_GET_ULP_OPS", "tcp_ulp_ops",
   [=](size_t idx, const one_tcp_ulp_ops *sb) {
    printf(" [%ld] at %p %s", idx, sb->addr, sb->name);
    dump_unnamed_kptr((unsigned long)sb->addr, delta);
    if ( sb->init )
     dump_kptr((unsigned long)sb->init, " init", delta);
    if ( sb->update )
     dump_kptr((unsigned long)sb->update, " update", delta);
    if ( sb->release )
     dump_kptr((unsigned long)sb->release, " release", delta);
    if ( sb->get_info )
     dump_kptr((unsigned long)sb->get_info, " get_info", delta);
    if ( sb->get_info_size )
     dump_kptr((unsigned long)sb->get_info_size, " get_info_size", delta);
    if ( sb->clone )
     dump_kptr((unsigned long)sb->clone, " clone", delta);
   }
  );
}

void dump_pernet_ops(int fd, a64 nca, a64 plock, sa64 delta)
{
  if ( !nca )
  {
    printf("cannot find pernet_list\n");
    return;
  }
  if ( !plock )
  {
    printf("cannot find pernet_ops_rwsem\n");
    return;
  }
  dump_data2arg<one_pernet_ops>(fd, nca, plock, delta, IOCTL_GET_PERNET_OPS, "pernet_ops", "IOCTL_GET_PERNET_OPS", "pernet_ops",
   [=](size_t idx, const one_pernet_ops *sb) {
    printf(" [%ld] at %p", idx, sb->addr);
    dump_unnamed_kptr((unsigned long)sb->addr, delta);
    if ( sb->init )
     dump_kptr((unsigned long)sb->init, " init", delta);
    if ( sb->exit )
     dump_kptr((unsigned long)sb->exit, " exit", delta);
    if ( sb->exit_batch )
     dump_kptr((unsigned long)sb->exit_batch, " exit_batch", delta);
   }
  );
}

static size_t calc_net_chains_size(size_t n)
{
  return (n + 1) * sizeof(unsigned long);
}

void dump_block_chain(int fd, a64 nca, sa64 delta, const char *name)
{
  unsigned long val = nca + delta;
  int err = ioctl(fd, IOCTL_CNTNTFYCHAIN, (int *)&val);
  if ( err )
  {
    printf("IOCTL_CNTSNTFYCHAIN for %s failed, error %d (%s)\n", name, errno, strerror(errno));
    return;
  }
  printf("\n%s at %p: count %ld\n", name, (void *)(nca + delta), val);
  if ( !val )
    return;
  size_t size = calc_net_chains_size(val);
  unsigned long *buf = (unsigned long *)malloc(size);
  if ( !buf )
    return;
  dumb_free<unsigned long> tmp(buf);
  buf[0] = nca + delta;
  buf[1] = val;
  err = ioctl(fd, IOCTL_ENUMNTFYCHAIN, (int *)buf);
  if ( err )
  {
    printf("IOCTL_ENUMNTFYCHAIN for %s failed, error %d (%s)\n", name, errno, strerror(errno));
    return;
  }
  for ( size_t i = 0; i < buf[0]; i++ )
  {
    printf(" [%ld]", i);
    dump_unnamed_kptr(buf[i+1], delta);
  }
}

void dump_net_chains(int fd, a64 nca, size_t cnt, sa64 delta)
{
  size_t size = calc_net_chains_size(cnt);
  unsigned long *buf = (unsigned long *)malloc(size);
  if ( !buf )
    return;
  dumb_free<unsigned long> tmp(buf);
  buf[0] = nca + delta;
  buf[1] = cnt;
  int err = ioctl(fd, IOCTL_GET_NETDEV_CHAIN, (int *)buf);
  if ( err )
  {
    printf("IOCTL_GET_NETDEV_CHAIN failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  size = buf[0];
  for ( size_t j = 0; j < size; j++ )
  {
    dump_unnamed_kptr(buf[1 + j], delta);
  }
}

void dump_genl(int fd, a64 addr, sa64 delta)
{
  if ( !addr )
  {
    printf("cannot find genl_fam_idr\n");
    return;
  }
  unsigned long args[2] = { addr + delta, 0 };
  int err = ioctl(fd, IOCTL_GET_GENL_FAMILIES, (int *)args);
  if ( err )
  {
    printf("IOCTL_GET_GENL_FAMILIES count failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  printf("\ngenl_fam_idr at %p: %ld\n", (void *)(addr + delta), args[0]);
  if ( !args[0] )
    return;
  size_t size = calc_data_size<one_genl_family>(args[0]);
  unsigned long *buf = (unsigned long *)malloc(size);
  if ( !buf )
    return;
  dumb_free<unsigned long> tmp(buf);
  buf[0] = addr + delta;
  buf[1] = args[0];
  err = ioctl(fd, IOCTL_GET_GENL_FAMILIES, (int *)buf);
  if ( err )
  {
    printf("IOCTL_GET_GENL_FAMILIES failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  size = buf[0];
  one_genl_family *curr = (one_genl_family *)(buf + 1);
  for ( size_t j = 0; j < size; j++, curr++ )
  {
    printf(" [%ld] at %p id %d %s", j, curr->addr, curr->id, curr->name);
    dump_unnamed_kptr((unsigned long)curr->addr, delta);
    if ( curr->pre_doit )
      dump_kptr((unsigned long)curr->pre_doit, " pre_doit", delta);
    if ( curr->post_doit )
      dump_kptr((unsigned long)curr->post_doit, " post_doit", delta);
    if ( curr->ops )
      dump_kptr((unsigned long)curr->ops, " ops", delta);
    if ( curr->small_ops )
      dump_kptr((unsigned long)curr->small_ops, " small_ops", delta);
  }
}

union netlink_args
{
  unsigned long args[3];
  struct one_nltab out;
};

static const char *const nlk_names[MAX_LINKS] = {
 "ROUTE",
 NULL,
 "USERSOCK",
 "FIREWALL",
 "SOCK_DIAG",
 "NFLOG",
 "XFRM",
 "SELINUX",
 "ISCSI",
 "AUDIT",
 "FIB_LOOKUP",
 "CONNECTOR",
 "NETFILTER",
 "IP6_FW",
 "DNRTMSG",
 "KOBJECT_UEVENT",
 "GENERIC",
 NULL,
 "SCSITRANSPORT",
 "ECRYPTFS",
 "RDMA",
 "CRYPTO",
 "SMC",
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
 NULL,
};

void dump_netlinks(int fd, a64 nca, a64 lock, sa64 delta)
{
  netlink_args args;
  if ( !nca )
  {
    printf("cannot get nl_table\n");
    return;
  }
  if ( !lock )
  {
    printf("cannot get nl_table_lock\n");
    return;
  }
  for ( int i = 0; i < MAX_LINKS; i++ )
  {
    args.args[0] = nca + delta;
    args.args[1] = lock + delta;
    args.args[2] = (unsigned long)i;
    int err = ioctl(fd, IOCTL_GET_NLTAB, (int *)&args);
    if ( err )
    {
      printf("IOCTL_GET_NLTAB index %d failed, error %d (%s)\n", i, errno, strerror(errno));
      return;
    }
    if ( nlk_names[i] )
      printf("nl_tab[%s] at %p registered %d sockets %ld\n", nlk_names[i], args.out.addr, args.out.registered, args.out.sk_count);
    else
      printf("nl_tab[%d] at %p registered %d sockets %ld\n", i, args.out.addr, args.out.registered, args.out.sk_count);
    if ( args.out.bind )
      dump_kptr((unsigned long)args.out.bind, "bind", delta);
    if ( args.out.unbind )
      dump_kptr((unsigned long)args.out.unbind, "unbind", delta);
    if ( args.out.compare )
      dump_kptr((unsigned long)args.out.compare, "compare", delta);
    if ( !args.out.sk_count )
      continue;
    size_t buf_size = calc_data_size<one_nl_socket>(args.out.sk_count);
    unsigned long *buf = (unsigned long *)malloc(buf_size);
    if ( !buf )
      continue;
    dumb_free<unsigned long> tmp(buf);
    buf[0] = nca + delta;
    buf[1] = lock + delta;
    buf[2] = (unsigned long)i;
    buf[3] = args.out.sk_count;
    err = ioctl(fd, IOCTL_GET_NL_SK, (int *)buf);
    if ( err )
    {
      printf("IOCTL_GET_NL_SK index %d failed, error %d (%s)\n", i, errno, strerror(errno));
      continue;
    }
    buf_size = buf[0];
    one_nl_socket *curr = (one_nl_socket *)(buf + 1);
    for ( size_t j = 0; j < buf_size; j++, curr++ )
    {
      printf(" sock[%ld] at %p portid %d sk_type %d sk_protocol %d flags %X subscriptions %d\n",
       j, curr->addr, curr->portid, curr->sk_type, curr->sk_protocol, curr->flags, curr->subscriptions
      );
      if ( curr->netlink_rcv )
        dump_kptr((unsigned long)curr->netlink_rcv, " netlink_rcv", delta);
      if ( curr->netlink_bind )
        dump_kptr((unsigned long)curr->netlink_bind, " netlink_bind", delta);
      if ( curr->netlink_unbind )
        dump_kptr((unsigned long)curr->netlink_bind, " netlink_unbind", delta);
      if ( curr->cb_dump )
        dump_kptr((unsigned long)curr->cb_dump, " cb.dump", delta);
      if ( curr->cb_done )
        dump_kptr((unsigned long)curr->cb_done, " cb.done", delta);
    }
  }
}

static size_t calc_proto_size(size_t n)
{
  if ( n < 2 )
    n = 2;
  return (n + 1) * sizeof(unsigned long);
}

void dump_protos(int fd, a64 nca, a64 lock, sa64 delta)
{
  if ( !nca )
  {
    printf("cannot find proto_list\n");
    return;
  }
  if ( !lock )
  {
    printf("cannot find proto_list_mutex\n");
    return;
  }
  unsigned long args[3] = { nca + delta, lock + delta, 0 };
  int err = ioctl(fd, IOCTL_GET_PROTOS, (int *)args);
  if ( err )
  {
    printf("IOCTL_GET_PROTOS count failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  printf("\nproto_list at %p: %ld\n", (void *)(nca + delta), args[0]);
  if ( !args[0] )
    return;
  size_t size = calc_proto_size(args[0]);
  unsigned long *buf = (unsigned long *)malloc(size);
  if ( !buf )
    return;
  dumb_free<unsigned long> tmp(buf);
  buf[0] = nca + delta;
  buf[1] = lock + delta;
  buf[2] = args[0];
  err = ioctl(fd, IOCTL_GET_PROTOS, (int *)buf);
  if ( err )
  {
    printf("IOCTL_GET_PROTOS failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  size = buf[0];
  for ( size_t i = 0; i < size; i++ )
  {
    printf(" [%ld] ", i);
    dump_unnamed_kptr(buf[1 + i], delta);
  }
}

void dump_nets(int fd, sa64 delta)
{
  unsigned long cnt = 0;
  int err = ioctl(fd, IOCTL_GET_NETS, (int *)&cnt);
  if ( err )
  {
    printf("IOCTL_GET_NETS count failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  printf("nets: %ld\n", cnt);
  if ( !cnt )
    return;
  size_t size = calc_data_size<one_net>(cnt);
  unsigned long *buf = (unsigned long *)malloc(size);
  if ( !buf )
    return;
  dumb_free<unsigned long> tmp(buf);
  buf[0] = cnt;
  err = ioctl(fd, IOCTL_GET_NETS, (int *)buf);
  if ( err )
  {
    printf("IOCTL_GET_NETS failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  size = buf[0];
  struct one_net *sb = (struct one_net *)(buf + 1);
  for ( size_t idx = 0; idx < size; idx++, sb++ )
  {
    printf("Net[%ld]: %p ifindex %d rtnl %p genl_sock %p diag_nlsk %p uevent_sock %p dev_cnt %ld netdev_chain_cnt %ld\n",
      idx, sb->addr, sb->ifindex, sb->rtnl, sb->genl_sock, sb->diag_nlsk, sb->uevent_sock, sb->dev_cnt, sb->netdev_chain_cnt
    );
    if ( sb->rtnl_proto )
      dump_kptr((unsigned long)sb->rtnl_proto, "rtnl_proto", delta);
    if ( sb->rtnl_filter )
      dump_kptr((unsigned long)sb->rtnl_filter, "rtnl_filter", delta);
    if ( sb->genl_sock_proto )
      dump_kptr((unsigned long)sb->genl_sock_proto, "genl_sock_proto", delta);
    if ( sb->genl_sock_filter )
      dump_kptr((unsigned long)sb->genl_sock_filter, "genl_sock_filter", delta);
    if ( sb->diag_nlsk_proto )
      dump_kptr((unsigned long)sb->diag_nlsk_proto, "diag_nlsk_proto", delta);
    if ( sb->diag_nlsk_filter )
      dump_kptr((unsigned long)sb->diag_nlsk_filter, "diag_nlsk_filter", delta);
    // dump bpf
    if ( sb->progs[0] )
      printf(" netns_bpf[0]: %p\n", sb->progs[0]);
    if ( sb->bpf_cnt[0] )
      printf(" bpf_cnt[0]: %ld\n", sb->bpf_cnt[0]);
    if ( sb->progs[1] )
      printf(" netns_bpf[1]: %p\n", sb->progs[1]);
    if ( sb->bpf_cnt[1] )
      printf(" bpf_cnt[1]: %ld\n", sb->bpf_cnt[1]);
    if ( !sb->dev_cnt )
      continue;
    size_t dsize = calc_data_size<one_net_dev>(sb->dev_cnt);
    unsigned long *dbuf = (unsigned long *)malloc(dsize);
    if ( !dbuf )
     continue;
    dumb_free<unsigned long> tmp2(dbuf);
    dbuf[0] = (unsigned long)sb->addr;
    dbuf[1] = sb->dev_cnt;
    err = ioctl(fd, IOCTL_GET_NET_DEVS, (int *)dbuf);
    if ( err )
    {
      printf("IOCTL_GET_NET_DEVS failed, error %d (%s)\n", errno, strerror(errno));
      continue;
    }
    dsize = dbuf[0];
    struct one_net_dev *nd = (struct one_net_dev *)(dbuf + 1);
    for ( size_t j = 0; j < dsize; j++, nd++ )
    {
      printf(" Dev[%ld]: %p %s ntfy_cnt %ld type %d mtu %d min_mtu %d max_mtu %d\n", 
        j, nd->addr, nd->name, nd->netdev_chain_cnt, nd->type, nd->mtu, nd->min_mtu, nd->max_mtu
      );
      if ( nd->netdev_ops )
        dump_kptr((unsigned long)nd->netdev_ops, " netdev_ops", delta);
      if ( nd->ethtool_ops )
        dump_kptr((unsigned long)nd->ethtool_ops, " ethtool_ops", delta);
      if ( nd->l3mdev_ops )
        dump_kptr((unsigned long)nd->l3mdev_ops, " l3mdev_ops", delta);
      if ( nd->ndisc_ops )
        dump_kptr((unsigned long)nd->ndisc_ops, " ndisc_ops", delta);
      if ( nd->xfrmdev_ops )
        dump_kptr((unsigned long)nd->xfrmdev_ops, " xfrmdev_ops", delta);
      if ( nd->tlsdev_ops )
        dump_kptr((unsigned long)nd->tlsdev_ops, " tlsdev_ops", delta);
      if ( nd->header_ops )
        dump_kptr((unsigned long)nd->header_ops, " header_ops", delta);
      if ( nd->xdp_prog )
        dump_kptr((unsigned long)nd->xdp_prog, " xdp_prog", delta);
      if ( nd->rx_handler )
        dump_kptr((unsigned long)nd->rx_handler, " rx_handler", delta);
      if ( nd->rtnl_link_ops )
        dump_kptr((unsigned long)nd->rtnl_link_ops, " rtnl_link_ops", delta);
      if ( nd->dcbnl_ops )
        dump_kptr((unsigned long)nd->dcbnl_ops, " dcbnl_ops", delta);
      if ( nd->macsec_ops )
        dump_kptr((unsigned long)nd->macsec_ops, " macsec_ops", delta);
      if ( nd->num_hook_entries )
        printf("num_hook_entries: %ld\n", nd->num_hook_entries);
      // dump xdp_state
      for ( int xdp = 0; xdp < 3; xdp++ )
      {
        if ( !nd->bpf_prog[xdp] && !nd->bpf_link[xdp] )
          continue;
        printf("  xdp_state[%d] prog %p link %p\n", xdp, nd->bpf_prog[xdp], nd->bpf_link[xdp]);
      }
    }
  }
  // sock diags
  for ( int i = 0; i < AF_MAX; i++ )
  {
    one_sock_diag sd;
    sd.addr = (void *)i;
    err = ioctl(fd, IOCTL_GET_SOCK_DIAG, (int *)&sd);
    if ( err )
    {
      printf("IOCTL_GET_SOCK_DIAG(%d) failed, error %d (%s)\n", i, errno, strerror(errno));
      continue;
    }
    if ( !sd.addr )
      continue;
    printf("sock_diag[%d]: %p\n", i, sd.addr);
    if ( sd.dump )
      dump_kptr((unsigned long)sd.dump, "dump", delta);
    if ( sd.get_info )
      dump_kptr((unsigned long)sd.get_info, "get_info", delta);
    if ( sd.destroy )
      dump_kptr((unsigned long)sd.destroy, "destroy", delta);
  }
  // netdev chains
  unsigned long nca = get_addr("netdev_chain");
  if ( nca )
  {
    unsigned long nc[2];
    nc[0] = nca + delta;
    nc[1] = 0;
    err = ioctl(fd, IOCTL_GET_NETDEV_CHAIN, (int *)nc);
    if ( err )
      printf("IOCTL_GET_NETDEV_CHAIN failed, error %d (%s)\n", errno, strerror(errno));
    else {
      printf("\nnetdev_chain at %p: %ld\n", (void *)(nca + delta), nc[0]);
      if ( nc[0] )
        dump_net_chains(fd, nca, nc[0], delta);
    }
  } else
    printf("cannot find netdev_chain");
  // proto list
  nca = get_addr("proto_list");
  auto plock = get_addr("proto_list_mutex");
  dump_protos(fd, nca, plock, delta);
  // ulp ops
  nca = get_addr("tcp_ulp_list"); 
  plock = get_addr("tcp_ulp_list_lock");
  dump_ulps(fd, nca, plock, delta);
  // pernet ops
  nca = get_addr("pernet_list");
  plock = get_addr("pernet_ops_rwsem");
  dump_pernet_ops(fd, nca, plock, delta);
  // link ops
  nca = get_addr("link_ops");
  if ( !nca )
    printf("cannot find link_ops");
  else
    dump_link_ops(fd, nca, delta);
  // rtnl_af_ops
  nca = get_addr("rtnl_af_ops");
  if ( !nca )
    printf("cannot find rtnl_af_ops");
  else
    dump_rtnl_af_ops(fd, nca, delta);
  // protosw
  nca = get_addr("inetsw");
  plock = get_addr("inetsw_lock");
  if ( !nca )
    printf("cannot find inetsw\n");
  else if ( !plock )
    printf("cannot find inetsw_lock\n");
  else
    dump_protosw(fd, nca, plock, delta, "inetsw");
  nca = get_addr("inetsw6");
  plock = get_addr("inetsw6_lock");
  if ( nca && plock )
    dump_protosw(fd, nca, plock, delta, "inetsw6");
  // network block chains
  nca = get_addr("netlink_chain");
  if ( nca )
    dump_block_chain(fd, nca, delta, "netlink_chain");
  nca = get_addr("inetaddr_chain");
  if ( nca )
    dump_block_chain(fd, nca, delta, "inetaddr_chain");
//  inet6addr_chain is ATOMIC_NOTIFIER
//  nca = get_addr("inet6addr_chain");
//  if ( nca )
//    dump_block_chain(fd, nca, delta, "inet6addr_chain");
  nca = get_addr("inetaddr_validator_chain");
  if ( nca )
    dump_block_chain(fd, nca, delta, "inetaddr_validator_chain");
  nca = get_addr("inet6addr_validator_chain");
  if ( nca )
    dump_block_chain(fd, nca, delta, "inet6addr_validator_chain");
  // dump netlinks
  nca = get_addr("nl_table");
  plock = get_addr("nl_table_lock");
  dump_netlinks(fd, nca, plock, delta);
  nca = get_addr("genl_fam_idr");
  dump_genl(fd, nca, delta);
}

// ripped from include/uapi/linux/stat.h
const char *get_mod_name(unsigned long mod)
{
   auto what = mod & 00170000;
   if ( what == 0140000 )
     return "SOCK";
   if ( what == 0120000 )
     return "LNK";
   if ( what == 0100000 )
     return "FILE";
   if ( what == 060000 )
     return "BLK";
   if ( what == 040000 )
     return "DIR";
   if ( what == 020000 )
     return "CHR";
   if ( what == 010000 )
     return "FIFO";
   return "???";
}

void dump_marks(unsigned long size, one_fsnotify *of, sa64 delta, const char *margin = "")
{
  std::string m = margin;
  m += " ops";
  for ( size_t k = 0; k < size; k++ )
  {
    printf("%s fsnotify[%ld] %p mask %X ignored_mask %X flags %X\n", margin, k, of[k].mark_addr, of[k].mask, of[k].ignored_mask, of[k].flags);
    if ( of[k].group )
      printf("%s group: %p\n", margin, of[k].group);
    if ( of[k].ops )
      dump_kptr((unsigned long)of[k].ops, m.c_str(), delta);
  }
}

void dump_super_blocks(int fd, sa64 delta)
{
  unsigned long cnt = 0;
  int err = ioctl(fd, IOCTL_GET_SUPERBLOCKS, (int *)&cnt);
  if ( err )
  {
    printf("IOCTL_GET_SUPERBLOCKS count failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  printf("super-blocks: %ld\n", cnt);
  if ( !cnt )
    return;
  size_t size = calc_data_size<one_super_block>(cnt);
  unsigned long *buf = (unsigned long *)malloc(size);
  if ( !buf )
    return;
  dumb_free<unsigned long> tmp(buf);
  buf[0] = cnt;
  err = ioctl(fd, IOCTL_GET_SUPERBLOCKS, (int *)buf);
  if ( err )
  {
    printf("IOCTL_GET_SUPERBLOCKS failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  size = buf[0];
//  printf("size %ld\n", size);
  init_mountinfo();
  struct one_super_block *sb = (struct one_super_block *)(buf + 1);
  for ( size_t idx = 0; idx < size; idx++ )
  {
    printf("superblock[%ld] at %p dev %ld flags %lX inodes %ld %s mnt_count %ld root %p %s\n", idx, sb[idx].addr, sb[idx].dev, sb[idx].s_flags, sb[idx].inodes_cnt, sb[idx].s_id, 
      sb[idx].mount_count, sb[idx].s_root, sb[idx].root
    );
    if ( sb[idx].s_type )
      dump_kptr((unsigned long)sb[idx].s_type, "s_type", delta);
    if ( sb[idx].s_op )
      dump_kptr((unsigned long)sb[idx].s_op, "s_op", delta);
    if ( sb[idx].dq_op )
      dump_kptr((unsigned long)sb[idx].dq_op, "dq_op", delta);
    if ( sb[idx].s_qcop )
      dump_kptr((unsigned long)sb[idx].s_qcop, "s_qcop", delta);
    if ( sb[idx].s_export_op )
      dump_kptr((unsigned long)sb[idx].s_export_op, "s_export_op", delta);
    if ( sb[idx].s_d_op )
      dump_kptr((unsigned long)sb[idx].s_d_op, "s_d_op", delta);
    if ( sb[idx].s_fsnotify_mask || sb[idx].s_fsnotify_marks )
      printf(" s_fsnotify_mask: %lX s_fsnotify_marks %p\n", sb[idx].s_fsnotify_mask, sb[idx].s_fsnotify_marks);
    // dump super-block marks
    unsigned long sb_marks_arg[2] = { (unsigned long)sb[idx].addr, 0 };
    err = ioctl(fd, IOCTL_GET_SUPERBLOCK_MARKS, (int *)sb_marks_arg);
    if ( err )
    {
      printf("IOCTL_GET_SUPERBLOCK_MARKS count failed, error %d (%s)\n", errno, strerror(errno));
    } else if ( sb_marks_arg[1] )
    {
      size_t mmsize = calc_data_size<one_fsnotify>(sb_marks_arg[1]);
      unsigned long *mmbuf = (unsigned long *)malloc(mmsize);
      if ( mmbuf )
      {
        // params for IOCTL_GET_SUPERBLOCK_MARKS
        mmbuf[0] = (unsigned long)sb[idx].addr;
        mmbuf[1] = sb_marks_arg[1];
        err = ioctl(fd, IOCTL_GET_SUPERBLOCK_MARKS, (int *)mmbuf);
        if ( err )
          printf("IOCTL_GET_SUPERBLOCK_MARKS failed, error %d (%s)\n", errno, strerror(errno));
        else
          dump_marks(mmbuf[0], (one_fsnotify *)(mmbuf + 1), delta);
        free(mmbuf);
      }
    }
    // dump mounts
    if ( sb[idx].mount_count )
    {
      size_t msize = calc_data_size<one_mount>(sb[idx].mount_count);
      unsigned long *mbuf = (unsigned long *)malloc(msize);
      if ( mbuf )
      {
        // params for IOCTL_GET_SUPERBLOCK_MOUNTS
        mbuf[0] = (unsigned long)sb[idx].addr;
        mbuf[1] = sb[idx].mount_count;
        err = ioctl(fd, IOCTL_GET_SUPERBLOCK_MOUNTS, (int *)mbuf);
        if ( err )
        {
          printf("IOCTL_GET_SUPERBLOCK_MOUNTS failed, error %d (%s)\n", errno, strerror(errno));
        } else {
          msize = mbuf[0];
          struct one_mount *mnt = (struct one_mount *)(mbuf + 1);
          for ( size_t j = 0; j < msize; j++ )
          {
            const char *path = NULL;
            if ( mnt[j].mnt_root[0] )
              path = mnt[j].mnt_root;
            else if ( mnt[j].root[0] )
              path = mnt[j].root;
            else if ( mnt[j].mnt_mp[0] )
              path = mnt[j].mnt_mp;
            else
              path = get_mnt(mnt[j].mnt_id);
            printf(" mnt[%ld] %p mark_cnt %ld mnt_id %d %s\n", j, mnt[j].addr, mnt[j].mark_count, mnt[j].mnt_id, path ? path : "");
            if ( !mnt[j].mark_count )
              continue;
            size_t mmsize = calc_data_size<one_fsnotify>(mnt[j].mark_count);
            unsigned long *mmbuf = (unsigned long *)malloc(mmsize);
            if ( !mmbuf )
              continue;
            // params for IOCTL_GET_MOUNT_MARKS
            mmbuf[0] = (unsigned long)sb[idx].addr;
            mmbuf[1] = (unsigned long)mnt[j].addr;
            mmbuf[2] = mnt[j].mark_count;
            err = ioctl(fd, IOCTL_GET_MOUNT_MARKS, (int *)mmbuf);
            if ( err )
            {
               printf("IOCTL_GET_MOUNT_MARKS failed, error %d (%s)\n", errno, strerror(errno));
               free(mmbuf);
               continue;
            }
            dump_marks(mmbuf[0], (one_fsnotify *)(mmbuf + 1), delta, "   ");
            free(mmbuf);
          }
        }
        free(mbuf);
      }
    }
    // dump inodes
    if ( !sb[idx].inodes_cnt )
      continue;
    auto isize = calc_data_size<one_inode>(sb[idx].inodes_cnt);
    unsigned long *ibuf = (unsigned long *)malloc(isize);
    if ( !ibuf )
      continue;
    dumb_free<unsigned long> itmp(ibuf);
    // params for IOCTL_GET_SUPERBLOCK_INODES
    ibuf[0] = (unsigned long)sb[idx].addr;
    ibuf[1] = sb[idx].inodes_cnt;
    err = ioctl(fd, IOCTL_GET_SUPERBLOCK_INODES, (int *)ibuf);
    if ( err )
    {
      printf("IOCTL_GET_SUPERBLOCK_INODES failed, error %d (%s)\n", errno, strerror(errno));
      continue;
    }
    isize = ibuf[0];
    struct one_inode *inod = (struct one_inode *)(ibuf + 1);
    for ( size_t j = 0; j < isize; j++ )
    {
      if ( !g_opt_v && !inod[j].i_fsnotify_mask && !inod[j].i_fsnotify_marks )
        continue;
      const char *mod = get_mod_name(inod[j].i_mode);
      printf("  inode[%ld] %p i_no %ld i_flags %X %s\n", j, inod[j].addr, inod[j].i_ino, inod[j].i_flags, mod);
      if ( inod[j].i_fsnotify_mask || inod[j].i_fsnotify_marks )
        printf("    i_fsnotify_mask: %lX i_fsnotify_marks %p count %ld\n", inod[j].i_fsnotify_mask, inod[j].i_fsnotify_marks, inod[j].mark_count);
      if ( !inod[j].mark_count )
        continue;
      size_t msize = calc_data_size<one_fsnotify>(inod[j].mark_count);
      unsigned long *fbuf = (unsigned long *)malloc(msize);
      if ( !fbuf )
        continue;
      // params for IOCTL_GET_INODE_MARKS
      fbuf[0] = (unsigned long)sb[idx].addr;
      fbuf[1] = (unsigned long)inod[j].addr;
      fbuf[2] = inod[j].mark_count;
      err = ioctl(fd, IOCTL_GET_INODE_MARKS, (int *)fbuf);
      if ( err )
      {
        printf("IOCTL_GET_INODE_MARKS failed, error %d (%s)\n", errno, strerror(errno));
        free(fbuf);
        continue;
      }
      dump_marks(fbuf[0], (one_fsnotify *)(fbuf + 1), delta, "   ");
      free(fbuf);
    }
  }
}

void dump_kprobes(int fd, sa64 delta)
{
  unsigned long a1 = get_addr("kprobe_table");
  if ( !a1 )
  {
    printf("cannot find kprobe_table\n");
    return;
  }
  unsigned long a2 = get_addr("kprobe_mutex");
  if ( !a2 )
  {
    printf("cannot find kprobe_mutex\n");
    return;
  }
  size_t curr_n = 3;
  size_t ksize = calc_data_size<one_kprobe>(curr_n);
  unsigned long *buf = (unsigned long *)malloc(ksize);
  if ( !buf )
    return;
  for ( int i = 0; i < 64; i++ )
  {
    unsigned long params[3] = { a1 + delta, a2 + delta, (unsigned long)i };
    int err = ioctl(fd, IOCTL_CNT_KPROBE_BUCKET, (int *)&params);
    if ( err )
    {
      printf("IOCTL_CNT_KPROBE_BUCKET(%d) failed, error %d (%s)\n", i, errno, strerror(errno));
      continue;
    }
    if ( !params[0] )
      continue;
    printf("kprobes[%d]: %ld\n", i, params[0]);
    // ok, we have some kprobes, read them all
    if ( params[0] > curr_n )
    {
      unsigned long *tmp;
      ksize = calc_data_size<one_kprobe>(params[0]);
      tmp = (unsigned long *)malloc(ksize);
      if ( tmp == NULL )
        break;
      curr_n = params[0];
      free(buf);
      buf = tmp;
    }
    // fill params
    buf[0] = a1 + delta;
    buf[1] = a2 + delta;
    buf[2] = (unsigned long)i;
    buf[3] = params[0];
    err = ioctl(fd, IOCTL_GET_KPROBE_BUCKET, (int *)buf);
    if ( err )
    {
      printf("IOCTL_GET_KPROBE_BUCKET(%d) failed, error %d (%s)\n", i, errno, strerror(errno));
      continue;
    }
    // dump
    ksize = buf[0];
    struct one_kprobe *kp = (struct one_kprobe *)(buf + 1);
    for ( size_t idx = 0; idx < ksize; idx++ )
    {
      if ( kp[idx].is_aggr )
        printf(" kprobe at %p flags %X aggregated\n", kp[idx].kaddr, kp[idx].flags);
      else
        printf(" kprobe at %p flags %X\n", kp[idx].kaddr, kp[idx].flags);
      dump_kptr((unsigned long)kp[idx].addr, " addr", delta);
      if ( kp[idx].pre_handler )
        dump_kptr((unsigned long)kp[idx].pre_handler, " pre_handler", delta);
      if ( kp[idx].post_handler )
        dump_kptr((unsigned long)kp[idx].post_handler, " post_handler", delta);
    }
  }
  if ( buf != NULL )
    free(buf);
}

void install_urn(int fd, int action)
{
  unsigned long param = action;
  int err = ioctl(fd, IOCTL_TEST_URN, (int *)&param);
  if ( err )
    printf("install_urn(%d) failed, error %d (%s)\n", action, errno, strerror(errno));
}

static size_t calc_urntfy_size(size_t n)
{
  return (n + 1) * sizeof(unsigned long);
}

void dump_return_notifier_list(int fd, unsigned long this_off, unsigned long off, sa64 delta)
{
  int cpu_num = get_nprocs();
  size_t curr_n = 3;
  size_t size = calc_urntfy_size(curr_n);
  unsigned long *ntfy = (unsigned long *)malloc(size);
  if ( ntfy == NULL )
    return;
  for ( int i = 0; i < cpu_num; i++ )
  {
    unsigned long buf[3] = { (unsigned long)i, this_off, off };
    int err = ioctl(fd, IOCTL_CNT_RNL_PER_CPU, (int *)buf);
    if ( err )
    {
      printf("dump_return_notifier_list count for cpu_id %d failed, error %d (%s)\n", i, errno, strerror(errno));
      break;
    }
    if ( buf[0] )
      printf("cpu[%d]: head %p %ld\n", i, (void *)buf[0], buf[1]);
    else
      printf("cpu[%d]: %ld\n", i, buf[1]);
    if ( !buf[1] )
      continue; // no ntfy on this cpu
    // read ntfy
    if ( buf[1] > curr_n )
    {
      unsigned long *tmp;
      size = calc_urntfy_size(buf[1]);
      tmp = (unsigned long *)malloc(size);
      if ( tmp == NULL )
        break;
      curr_n = buf[1];
      free(ntfy);
      ntfy = tmp;
    }
    // fill params
    ntfy[0] = (unsigned long)i;
    ntfy[1] = this_off;
    ntfy[2] = off;
    ntfy[3] = buf[1];
    err = ioctl(fd, IOCTL_RNL_PER_CPU, (int *)ntfy);
    if ( err )
    {
      printf("dump_return_notifier_list for cpu_id %d cnt %ld failed, error %d (%s)\n", i, buf[1], errno, strerror(errno));
      break;
    }
    // dump
    size = ntfy[0];
    for ( size_t j = 0; j < size; j++ )
    {
      dump_kptr(ntfy[1 + j], "ntfy", delta);
    }
  }
  if ( ntfy != NULL )
    free(ntfy);
}

void dump_efivar_ops_field(int fd, char *ptr, const char *fname, sa64 delta)
{
  char *arg = ptr;
  int err = ioctl(fd, IOCTL_READ_PTR, (int *)&arg);
   if ( err )
     printf("cannot read %s at %p, err %d\n", fname, ptr, err);
   else if ( arg )
     dump_kptr((unsigned long)arg, fname, delta);
}

// generic_efivars is struct efivars - 2nd ptr is efivar_operations which has 5 function pointers
// see https://elixir.bootlin.com/linux/v5.14-rc7/source/include/linux/efi.h#L948
void dump_efivars(int fd, a64 saddr, sa64 delta)
{
   char *ptr = (char *)saddr + delta + 2 * sizeof(void *);
   char *arg = ptr;
   int err = ioctl(fd, IOCTL_READ_PTR, (int *)&arg);
   if ( err )
   {
      printf("dump_efivars: read at %p failed, error %d (%s)\n", ptr, errno, strerror(errno));
      return;
   }
   if ( !arg )
     return;
   if ( is_inside_kernel((unsigned long)arg) )
      printf("efivar_operations at %p: %p - kernel\n", ptr, arg);
   else {
     const char *mname = find_kmod((unsigned long)arg);
     if ( mname )
       printf("efivar_operations at %p: %p - %s\n", ptr, arg, mname);
     else
       printf("efivar_operations at %p: %p UNKNOWN\n", ptr, arg);
   }
   // dump all five fields
   ptr = arg;
   dump_efivar_ops_field(fd, ptr, "get_variable", delta);

   ptr += sizeof(void *);
   dump_efivar_ops_field(fd, ptr, "get_variable_next", delta);

   ptr += sizeof(void *);
   dump_efivar_ops_field(fd, ptr, "set_variable", delta);

   ptr += sizeof(void *);
   dump_efivar_ops_field(fd, ptr, "set_variable_nonblocking", delta);

   ptr += sizeof(void *);
   dump_efivar_ops_field(fd, ptr, "query_variable_store", delta);
}

void dump_usb_mon(int fd, a64 saddr, sa64 delta)
{
   char *ptr = (char *)saddr + delta;
   char *arg = ptr;
   int err = ioctl(fd, IOCTL_READ_PTR, (int *)&arg);
   if ( err )
   {
      printf("dump_usb_mon: read at %p failed, error %d (%s)\n", ptr, errno, strerror(errno));
      return;
   }
   if ( arg )
   {
     if ( is_inside_kernel((unsigned long)arg) )
       printf("mon_ops at %p: %p - kernel\n", (char *)saddr + delta, arg);
     else {
       const char *mname = find_kmod((unsigned long)arg);
       if ( mname )
         printf("mon_ops at %p: %p - %s\n", (char *)saddr + delta, arg, mname);
       else
         printf("mon_ops at %p: %p UNKNOWN\n", (char *)saddr + delta, arg);
     }
   } else 
     printf("mon_ops at %p: %p\n", (char *)saddr + delta, arg);
   if ( !arg )
     return;
   // see https://elixir.bootlin.com/linux/v5.14-rc7/source/include/linux/usb/hcd.h#L702
   // we need read 3 pointers at ptr
   ptr = arg;
   dump_efivar_ops_field(fd, ptr, "urb_submit", delta);

   ptr += sizeof(void *);
   dump_efivar_ops_field(fd, ptr, "urb_submit_error", delta);
 
   ptr += sizeof(void *);
   dump_efivar_ops_field(fd, ptr, "urb_complete", delta);
}

static size_t calc_tp_size(size_t n)
{
  return sizeof(unsigned long) + n * sizeof(one_tracepoint_func);
}

void check_tracepoints(int fd, sa64 delta, addr_sym *tsyms, size_t tcount)
{
  // alloc enough memory for tracepoint info
  size_t i, j, curr_n = 3;
  size_t size = calc_tp_size(curr_n);
  unsigned long *ntfy = (unsigned long *)malloc(size);
  if ( ntfy == NULL )
    return;
  for ( i = 0; i < tcount; i++ )
  {
    a64 addr = (a64)((char *)tsyms[i].addr + delta);
    ntfy[0] = addr;
    int err = ioctl(fd, IOCTL_TRACEPOINT_INFO, (int *)ntfy);
    if ( err )
    {
      printf("error %d while read tracepoint info for %s at %p\n", err, tsyms[i].name, (void *)addr);
      continue;
    }
    printf(" %s at %p: enabled %d cnt %d\n", tsyms[i].name, (void *)addr, (int)ntfy[0], (int)ntfy[3]);
    // 1 - regfunc
    if ( ntfy[1] )
       dump_kptr(ntfy[1], " regfunc", delta);
    // 2 - unregfunc
    if ( ntfy[2] )
       dump_kptr(ntfy[2], " unregfunc", delta);
    if ( !ntfy[3] )
      continue;
    auto curr_cnt = ntfy[3];
    if ( curr_cnt > curr_n )
    {
      unsigned long *tmp;
      size = calc_tp_size(addr);
      tmp = (unsigned long *)malloc(size);
      if ( tmp == NULL )
        break;
      curr_n = curr_cnt;
      free(ntfy);
      ntfy = tmp;
    }
    // dump funcs
    ntfy[0] = addr;
    ntfy[1] = curr_cnt;
    err = ioctl(fd, IOCTL_TRACEPOINT_FUNCS, (int *)ntfy);
    if ( err )
    {
      printf("error %d while read tracepoint funcs for %s at %p\n", err, tsyms[i].name, (void *)addr);
      continue;
    }
    size = ntfy[0];
    one_tracepoint_func *curr = (one_tracepoint_func *)(ntfy + 1);
    for ( j = 0; j < size; j++ , curr++ )
    {
      printf("  [%ld] data %p", j, (void *)curr->data);
      dump_unnamed_kptr(curr->addr, delta);
    }
  }
  free(ntfy);
}
#endif /* !_MSC_VER */

int is_nop(unsigned char *body)
{
  // nop dword ptr [rax+rax+00h] - 0F 1F 44 00 00
  if ( body[0] == 0xF  &&
       body[1] == 0x1F &&
       body[2] == 0x44 &&
       body[3] == 0    &&
       body[4] == 0
     )
   return 1;
  // just 90
  if ( body[0] == 0x90 &&
       body[1] == 0x90 &&
       body[2] == 0x90 &&
       body[3] == 0x90 &&
       body[4] == 0x90
     )
   return 1;
  return 0;
}

void dump_addr_name(a64 addr)
{
   const char *name = lower_name_by_addr(addr);
   if ( name != NULL )
      printf("%p # %s\n", (void *)addr, name);
   else
      printf("%p\n", (void *)addr);
}

int main(int argc, char **argv)
{
   // read options
   int opt_f = 0,
       opt_F = 0,
       opt_g = 0,
       opt_d = 0,
       opt_c = 0,
       opt_k = 0,
       opt_n = 0,
       opt_r = 0,
       opt_s = 0,
       opt_S = 0,
       opt_t = 0,
       opt_b = 0,
       opt_B = 0,
       opt_u = 0;
   int c;
   int fd = 0;
   while (1)
   {
     c = getopt(argc, argv, "BbcdFfghHknrSstuvj:");
     if (c == -1)
	break;

     switch (c)
     {
#ifndef _MSC_VER
        case 'j':
          if ( !ujit_open(optarg) )
           fprintf(stderr, "cannot dlopen %s, err %d\n", optarg, errno);
         break;
#endif /* _MSC_VER */
        case 'B':
          opt_B = 1;
         break;
        case 'b':
          opt_b = 1;
         break;
 	case 'F':
 	  opt_F = 1;
         break;
 	case 'f':
 	  opt_f = 1;
         break;
        case 'g':
 	  opt_g = 1;
         break;
        case 'h':
 	  g_opt_h = 1;
         break;
        case 'H':
          g_dump_bpf_ops = 1;
         break;
        case 'v':
          g_opt_v = 1;
         break;
        case 'd':
          opt_d = 1;
         break;
        case 'c':
          opt_c = 1;
         break;
        case 'k':
          opt_k = 1;
          opt_c = 1;
         break;
        case 'n':
          opt_n = 1;
         break;
        case 'r':
          opt_r = 1;
         break;
        case 's':
          opt_s = 1;
          opt_c = 1;
         break;
        case 'S':
          opt_S = 1;
         break;
        case 'u':
          opt_u = 1;
          opt_c = 1;
         break;
        case 't':
          opt_t = 1;
         break;
        default:
         usage(argv[0]);
     }
   }
   if (optind == argc)
     usage(argv[0]);

   elfio reader;
   int has_syms = 0;
   if ( !reader.load( argv[optind] ) ) 
   {
      printf( "File %s is not found or it is not an ELF file\n", argv[optind] );
      return 1;
   }
   optind++;
   Elf_Half n = reader.sections.size();
   for ( Elf_Half i = 0; i < n; ++i ) { // For all sections
     section* sec = reader.sections[i];
     if ( SHT_SYMTAB == sec->get_type() ||
          SHT_DYNSYM == sec->get_type() ) 
     {
       symbol_section_accessor symbols( reader, sec );
       if ( !read_syms(reader, symbols) )
         has_syms++;
     }
   }
   // try to find symbols
   if ( !has_syms && optind != argc )
   {
     int err = read_ksyms(argv[optind]);
     if ( err )
     {
       printf("cannot read %s, error %d\n", argv[optind], err);
       return err;
     }
     has_syms = 1;
     optind++;
   }
   sa64 delta = 0;
   a64 bpf_target = 0;
#ifndef _MSC_VER
   // open driver
   if ( opt_c ) 
   {
     fd = open("/dev/lkcd", 0);
     if ( -1 == fd )
     {
       printf("cannot open device, error %d\n", errno);
       opt_c = 0;
       goto end;
     }
     // find delta between symbols from system.map and loaded kernel
     auto symbol_a = get_addr("group_balance_cpu");
     if ( !symbol_a )
     {
       close(fd);
       fd = 0;
       opt_c = 0;
       goto end;
     } else {
       if ( read_kernel_area(fd) )
       {
         close(fd);
         fd = 0;
         opt_c = 0;
         goto end;
       }
       int err = init_kmods();
       if ( err )
       {
         printf("init_kmods failed, error %d\n", err);
         goto end;
       }
       printf("group_balance_cpu from symbols: %p\n", (void *)symbol_a);
       union ksym_params kparm;
       strcpy(kparm.name, "group_balance_cpu");
       err = ioctl(fd, IOCTL_RKSYM, (int *)&kparm);
       if ( err )
       {
         printf("IOCTL_RKSYM test failed, error %d\n", err);
         close(fd);
         fd = 0;
         opt_c = 0;
       } else {
         printf("group_balance_cpu: %p\n", (void *)kparm.addr);
         delta = (char *)kparm.addr - (char *)symbol_a;
         printf("delta: %lX\n", delta);
       }
     }
     // dump kprobes
     if ( opt_k && opt_c )
     {
       dump_kprobes(fd, delta);
       dump_uprobes(fd, delta);
     }
     // dump super-blocks
     if ( opt_F && opt_c )
       dump_super_blocks(fd, delta);
     if ( opt_c && opt_n )
       dump_nets(fd, delta);
     // check sysfs f_ops
     if ( opt_c && opt_s )
     {
       if ( optind == argc )
       {
         printf("where is files?\n");
         exit(6);
       }
       union kernfs_params kparm;
       for ( int idx = optind; idx < argc; idx++ )
       {
         strncpy(kparm.name, argv[idx], sizeof(kparm.name) - 1);
         kparm.name[sizeof(kparm.name) - 1] = 0;
         int err = ioctl(fd, IOCTL_KERNFS_NODE, (int *)&kparm);
         if ( err )
         {
           printf("IOCTL_KERNFS_NODE(%s) failed, error %d\n", argv[idx], err);
           continue;
         }
         printf("res %s: %p\n", argv[idx], (void *)kparm.res.addr);
         if ( kparm.res.addr )
         {
           // dump flags
           printf(" flags: %lX", kparm.res.flags);
           if ( kparm.res.flags & 1 )
             printf(" DIR");
           if ( kparm.res.flags & 2 )
             printf(" FILE");
           if ( kparm.res.flags & 4 )
             printf(" LINK");
           printf("\n");

           printf(" priv: %p\n", (void *)kparm.res.priv);
           if ( kparm.res.kobject )
             printf("kobject: %p\n", (void *)kparm.res.kobject);
           if ( kparm.res.ktype )
             dump_kptr(kparm.res.ktype, "ktype", delta);
           if ( kparm.res.sysfs_ops )
             dump_kptr(kparm.res.sysfs_ops, "sysfs_ops", delta);
           if ( kparm.res.show )
             dump_kptr(kparm.res.sysfs_ops, "sysfs_ops.show", delta);
           if ( kparm.res.store )
             dump_kptr(kparm.res.sysfs_ops, "sysfs_ops.store", delta);
         } else {
           printf(" inode: %p\n", (void *)kparm.res.flags);
           if ( kparm.res.s_op )
             dump_kptr(kparm.res.s_op, "s_op", delta);
           if ( kparm.res.priv )
             dump_kptr(kparm.res.priv, "inode->i_fop", delta);
           if ( kparm.res.ktype )
             dump_kptr(kparm.res.ktype, "debugfs_real_fops", delta);
           if ( kparm.res.sysfs_ops )
             dump_kptr(kparm.res.sysfs_ops, "private_data", delta);
         }
       }
     }
   }
end:
#endif /* _MSC_VER */
   // find .text section
   Elf64_Addr text_start = 0;
   Elf_Xword text_size = 0;
   section *text_section = NULL;
   for ( Elf_Half i = 0; i < n; ++i ) { // For all sections
     section* sec = reader.sections[i];
     if ( sec->get_name() == ".text" )
     {
       text_start = sec->get_address();
       text_size  = sec->get_size();
       text_section = sec;
       break;
     }
   }
   if ( has_syms )
   {
     // make some tests
     auto a1 = get_addr("__start_mcount_loc");
     printf("__start_mcount_loc: %p\n", (void *)a1);
     auto a2 = get_addr("__stop_mcount_loc");
     printf("__stop_mcount_loc: %p\n", (void *)a2);
     // if we had -f option
     if ( opt_f && a1 && a2 )
     {
       // under arm64 we need process relocs
       if ( reader.get_machine() == 183 )
         dump_arm64_ftraces(reader, a1, a2, [](Elf_Sxword addend) 
          { 
            dump_addr_name(addend);
          }
         );
       else {
         const a64 *data = (const a64 *)find_addr(reader, a1);
         if ( data != NULL )
         {
           for ( a64 i = a1; i < a2; i += sizeof(a64) )
           {
             a64 addr = *data;
             dump_addr_name(addr);
             data++;
#ifndef _MSC_VER
             if ( opt_c )
             {
               // filter out maybe discarded sections like .init.text
               if ( text_section != NULL &&
                    ( (addr < text_start) || (addr > (text_start + text_size)) )
                  )
                 continue;
               char *ptr = (char *)addr + delta;
               char *arg = ptr;
               int err = ioctl(fd, IOCTL_READ_PTR, (int *)&arg);
               if ( err )
                 printf("read ftrace at %p failed, error %d (%s)\n", ptr, errno, strerror(errno));
               else if ( !is_nop((unsigned char *)&arg) )
                 HexDump((unsigned char *)&arg, sizeof(arg));
             }
#endif /* !_MSC_VER */
           }
         }
       }
     }
   }

   if ( !text_start )
   {
     printf("cannot find .text\n");
     return 1;
   }
   for ( Elf_Half i = 0; i < n; ++i ) 
   {
     section* sec = reader.sections[i];
     if ( opt_r && sec->get_name() == ".rodata" )
     {
       std::map<a64, a64> filled;
       auto off = sec->get_offset();
       printf(".rodata section offset %lX\n", off);
       size_t count = 0;
       a64 curr_addr;
       // under arm64 we need count relocs in .data section       
       if ( reader.get_machine() == 183 )
       {
         a64 dstart = (a64)sec->get_address();
         count = filter_arm64_relocs(reader, dstart, dstart + sec->get_size(), (a64)text_start, (a64)(text_start + text_size), filled);
       } else {
         a64 *curr = (a64 *)sec->get_data();
         a64 *end  = (a64 *)((char *)curr + sec->get_size());
         curr_addr = sec->get_address();
         const endianess_convertor &conv = reader.get_convertor();
         for ( ; curr < end; curr++, curr_addr += sizeof(a64) )
         {
           auto addr = conv(*curr);
           if ( addr >= (a64)text_start &&
                addr < (a64)(text_start + text_size)
              )
           {
             count++;
             filled[curr_addr] = addr;
           }
         }
       }
       printf("found in .rodata %ld\n", count);
       // dump or check collected addresses
       if ( g_opt_v || opt_c )
         dump_and_check(fd, opt_c, delta, has_syms, filled);
       continue;
     }
     if ( sec->get_name() == ".data" )
     {
       std::map<a64, a64> filled;
       auto off = sec->get_offset();
       printf(".data section offset %lX\n", off);
       size_t count = 0;
       a64 curr_addr;
       // dump cgroups
       if ( opt_g && opt_c && has_syms )
       {
#ifndef _MSC_VER
         dump_groups(fd, delta);
#endif  /* !_MSC_VER */
       }
       if ( opt_u && has_syms )
       {
         a64 addr = get_addr("mon_ops");
         if ( !addr )
           printf("cannot find mon_ops\n");
#ifndef _MSC_VER
         else
           dump_usb_mon(fd, addr, delta);
#endif /* !_MSC_VER */
         addr = get_addr("generic_efivars");
         if ( !addr )
           printf("cannot find generic_efivars\n");
#ifndef _MSC_VER
         else
           dump_efivars(fd, addr, delta);
#endif /* !_MSC_VER */
       }
       if ( opt_t && has_syms )
       {
         size_t tcount = 0;
         a64 dstart = (a64)sec->get_address();
         struct addr_sym *tsyms = start_with("__tracepoint_", dstart, dstart + sec->get_size(), &tcount);
         if ( tsyms != NULL )
         {
           printf("found %ld tracepoints\n", tcount);
#ifdef _MSC_VER
           if ( g_opt_v )
           {
             for ( size_t i = 0; i < tcount; i++ )
               printf(" %p: %s\n", (void *)(tsyms[i].addr), tsyms[i].name);
           }
#else
           if ( opt_c )
             check_tracepoints(fd, delta, tsyms, tcount);
#endif /* _MSC_VER */
           free(tsyms);
         }
         dump_ftrace_options(fd, delta);
         // dump bpf raw events
         auto start = get_addr("__start__bpf_raw_tp");
         auto end   = get_addr("__stop__bpf_raw_tp");
         dump_bpf_raw_events(fd, start, end, delta);
         // dump ftrace_ops
         auto fops = get_addr("ftrace_ops_list");
         auto m = get_addr("ftrace_lock");
         dump_ftrace_ops(fd, fops, m, delta);
         // dump ftrace events
         auto ev_start = get_addr("__start_ftrace_events");
         auto ev_stop  = get_addr("__stop_ftrace_events");
         if ( !ev_start )
           printf("cannot find __start_ftrace_events\n");
         else if ( !ev_stop )
           printf("cannot find __stop_ftrace_events\n");
         else {
           printf("__start_ftrace_events: %p\n", (void *)ev_start);
           printf("__stop_ftrace_events: %p\n", (void *)ev_stop);
           std::set<a64> events;
           if ( reader.get_machine() == 183 )
           {
             dump_arm64_ftraces(reader, ev_start, ev_stop, [&events](Elf_Sxword addend) 
              {
               if ( g_opt_v )
                 dump_addr_name(addend);
               events.insert((a64)addend);
              }
             );
           } else {
             const a64 *data = (const a64 *)find_addr(reader, ev_start);
             if ( data != NULL )
               for ( a64 i = ev_start; i < ev_stop; i += sizeof(a64) )
               {
                 if ( g_opt_v )
                   dump_addr_name(*data);
                 events.insert(*data);
                 data++;
               }
           }
         }
#ifndef _MSC_VER
         if ( opt_c )
         {
           auto idr = get_addr("pmu_idr");
           auto m = get_addr("pmus_lock");
           dump_pmus(fd, idr, m, delta);
           // registered trace_event_calls
           dump_registered_trace_event_calls(fd, delta);
           // event cmds
           auto ecl = get_addr("trigger_commands");
           auto ecm = get_addr("trigger_cmd_mutex");
           dump_event_cmds(fd, ecl, ecm, delta);
           // trace exports
           ecl = get_addr("ftrace_exports_list");
           ecm = get_addr("ftrace_export_lock");
           dump_trace_exports(fd, ecl, ecm, delta);
           // ftrace cmds
           ecl = get_addr("ftrace_commands");
           ecm = get_addr("ftrace_cmd_mutex");
           dump_tracefunc_cmds(fd, ecl, ecm, delta);
           // dynamic events ops
           ecl = get_addr("dyn_event_ops_list");
           ecm = get_addr("dyn_event_ops_mutex");
           dump_dynevents_ops(fd, ecl, ecm, delta);
         }
#endif /* _MSC_VER */
       }
       // under arm64 we need count relocs in .data section       
       if ( reader.get_machine() == 183 )
       {
         a64 dstart = (a64)sec->get_address();
         count = filter_arm64_relocs(reader, dstart, dstart + sec->get_size(), (a64)text_start, (a64)(text_start + text_size), filled);
       } else {
         a64 *curr = (a64 *)sec->get_data();
         a64 *end  = (a64 *)((char *)curr + sec->get_size());
         curr_addr = sec->get_address();
         const endianess_convertor &conv = reader.get_convertor();
         for ( ; curr < end; curr++, curr_addr += sizeof(a64) )
         {
           auto addr = conv(*curr);
           if ( addr >= (a64)text_start &&
                addr < (a64)(text_start + text_size)
              )
           {
             count++;
             filled[curr_addr] = addr;
           }
         }
       }
       printf("found %ld\n", count);
       // dump or check collected addresses
       if ( g_opt_v || opt_c )
         dump_and_check(fd, opt_c, delta, has_syms, filled);
       if ( opt_d )
       {
          dis_base *bd = NULL;
          if ( reader.get_machine() == 183 )
          {
            arm64_disasm *ad = new arm64_disasm(text_start, text_size, text_section->get_data(), sec->get_address(), sec->get_size());
            a64 addr = get_addr("__stack_chk_fail");
            if ( addr )
              ad->add_noreturn(addr);
            bd = ad;
          } else if ( reader.get_machine() == EM_X86_64 )
          {
            x64_disasm *x64 = new x64_disasm(text_start, text_size, text_section->get_data(), sec->get_address(), sec->get_size());
            // fill indirect thunks
            for ( auto &c: s_x64_thunks )
            {
              a64 thunk_addr = get_addr(c.name);
              if ( !thunk_addr )
                printf("cannot find %s\n", c.name);
              else
                x64->set_indirect_thunk(thunk_addr, c.reg);
             }
             a64 ntfy_addr = get_addr("fire_user_return_notifiers");
             if ( !ntfy_addr )
               printf("cannot find fire_user_return_notifiers\n");
             else {
               if ( x64->find_return_notifier_list(ntfy_addr) )
               {
                 unsigned long this_cpu_off = 0,
                               return_notifier_list = 0;
                 if ( x64->get_return_notifier_list(this_cpu_off, return_notifier_list) )
                 {
                   printf("this_cpu_off: %lX, return_notifier_list: %lX\n", this_cpu_off, return_notifier_list);
#ifndef _MSC_VER
                   if ( opt_c )
                   {
                     install_urn(fd, 1);
                     dump_return_notifier_list(fd, this_cpu_off, return_notifier_list, delta);
                     install_urn(fd, 0);
                   }
#endif
                 }
               } else
                 printf("cannot extract return_notifier_list\n");
             }
             bd = x64;
          } else {
            printf("no disasm for machine %d\n", reader.get_machine());
            break;
          }
          if ( opt_B || opt_t )
          {
            // find bpf targets
            auto entry = get_addr("bpf_iter_reg_target");
            auto mlock = get_addr("mutex_lock");
            if ( !entry )
              printf("cannot find bpf_iter_reg_target\n");
            else if ( !mlock )
              printf("cannot find mutex_lock\n");
            else
              bpf_target = bd->process_bpf_target(entry, mlock);
            // dump bpf
            if ( opt_B && opt_c && has_syms )
            {
#ifndef _MSC_VER
               dump_jit_options(fd, delta);
               auto tgm = get_addr("targets_mutex");
               dump_bpf_targets(fd, bpf_target, tgm, delta);
               // bpf maps
               std::map<void *, std::string> names;
               auto entry = get_addr("map_idr");
               tgm = get_addr("map_idr_lock");
               dump_bpf_maps(fd, entry, tgm, delta, names);
               // bpf ksyms
               entry = get_addr("bpf_kallsyms");
               tgm = get_addr("bpf_lock");
               dump_bpf_ksyms(fd, entry, tgm, delta);
               // bpf progs
               if ( ujit_opened() )
               {
                 a64 base = get_addr("__bpf_call_base");
                 a64 enter = get_addr("__bpf_prog_enter");
                 a64 ex = get_addr("__bpf_prog_exit");
                 if ( base && enter && ex )
                 {
                   printf("__bpf_call_base %lX\n", base + delta);
                   put_kdata(base + delta, enter + delta, ex + delta);
                 }
               }
               entry = get_addr("prog_idr");
               tgm = get_addr("prog_idr_lock");
               dump_bpf_progs(fd, entry, tgm, delta, names);
               // bpf links
               entry = get_addr("link_idr");
               tgm = get_addr("link_idr_lock");
               dump_bpf_links(fd, entry, tgm, delta);
#endif /* !_MSC_VER */
            }
          }
          if ( opt_t )
          {
            // find trace_event_call.filter offset
            auto entry = get_addr("trace_remove_event_call");
            auto free_evt = get_addr("free_event_filter");
            if ( !entry )
              printf("cannot find trace_remove_event_call\n");
            else if ( !free_evt )
              printf("cannot find trace_remove_event_call\n");
            else
              g_event_foff = bd->process_trace_remove_event_call(entry, free_evt);
          }
          if ( opt_S )
          {
            s_security_hook_heads = get_addr("security_hook_heads");
            if ( !s_security_hook_heads )
            {
              printf("cannot find security_hook_heads\n");
              opt_S = 0;
            } else {
              int res = 0;
              bd->set_shook(s_security_hook_heads);
              for ( auto &sl: s_hooks )
              {
                std::string sl_name = "security_";
                sl_name += sl.name;
                sl.addr = get_addr(sl_name.c_str());
                if ( sl.addr )
                  res++;
              }
              if ( res )
                res = bd->process_sl(s_hooks);
              if ( !res )
                opt_S = 0;
              else 
              {
                if ( g_opt_v )
                {
                  for ( auto &sl: s_hooks )
                  {
                    if ( !sl.list )
                      continue;
                    printf("%s: %p\n", sl.name.c_str(), (void *)sl.list);
                  }
                }
#ifndef _MSC_VER
                if ( opt_c )
                  dump_lsm(fd, delta);
#endif /* !_MSC_VER */
              }
            }
          }
          // find bss if we need
          if ( opt_b )
          {
            for ( Elf_Half j = 0; j < n; ++j )
            {
              section* s = reader.sections[j];
              if ( (s->get_type() & SHT_NOBITS) && 
                   (s->get_name() == ".bss" )
                 )
              {
                a64 bss_addr = s->get_address();
                if ( g_opt_v )
                  printf(".bss address %p size %lX\n", (void *)bss_addr, s->get_size());
                bd->set_bss(bss_addr, s->get_size());
                break;
              }
            }
          }
          std::set<a64> out_res;
          size_t tcount = 0;
          struct addr_sym *tsyms = get_in_range(text_start, text_start + text_size, &tcount);
          if (tsyms != NULL)
          {
#ifdef _DEBUG
            a64 taddr = get_addr("netdev_store.isra.14");
            if ( taddr )
              bd->process(taddr, filled, out_res);
#endif /* _DEBUG */
            for (size_t i = 0; i < tcount; i++)
            {
#ifdef _DEBUG
              printf("%s:\n", tsyms[i].name);
#endif /* _DEBUG */
              bd->process(tsyms[i].addr, filled, out_res);
            }
            free(tsyms);
          }
          else
          {
            // now disasm some funcs - security_load_policy
            a64 faddr = get_addr("rcu_sched_clock_irq");
            if (faddr)
            {
              bd->process(faddr, filled, out_res);
            }
          }
          delete bd;
          printf("found with disasm: %ld\n", out_res.size());
          if ( g_opt_v )
          {
            for ( auto c: out_res )
            {
              size_t off = 0;
              const char *name = lower_name_by_addr_with_off(c, &off);
              if ( name != NULL )
              {
                if ( off )
                  printf("# %s+%lX\n", name, off);
                else
                  printf("# %s\n", name);
              }
              printf("%p\n", (void *)c);
            }
          }
#ifndef _MSC_VER
          if ( opt_c )
          {
            for ( auto c: out_res )
            {
              char *ptr = (char *)c + delta;
              char *arg = ptr;
              int err = ioctl(fd, IOCTL_READ_PTR, (int *)&arg);
              if ( err )
                printf("read at %p failed, error %d (%s)\n", ptr, errno, strerror(errno));
              else if ( arg != NULL )
              {
                 if ( is_inside_kernel((unsigned long)arg) )
                 {
                    if ( !has_syms )
                      printf("mem at %p: %p\n", ptr, arg);
                    else
                      dump_patched(c, ptr, arg, delta);
                 } else {
                    const char *mname = find_kmod((unsigned long)arg);
                    if ( mname )
                      printf("mem at %p: %p - patched by %s\n", ptr, arg, mname);
                    else
                      printf("mem at %p: %p - patched by UNKNOWN\n", ptr, arg);
                 }
              }
            }
          } // opt_c
#endif /* !_MSC_VER */
       } // opt_d
       break;
     }
   }
#ifndef _MSC_VER
   if ( fd )
     close(fd);
   ujit_close();
#endif /* _MSC_VER */
}
